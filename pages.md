# SRE 平台頁面功能分析

本文件基於 `images/` 目錄中的頁面截圖，分析每個功能模組的設計、API 需求和使用者體驗優化建議。

## 頁面截圖（按編號順序排列）

```bash
.
├── 00-頁面-登入.png
├── 01-彈窗-使用者選單.png
├── 02-彈窗-通知中心.png
├── 10-頁面-事件列表.png
├── 11-頁面-事件規則.png
├── 12-頁面-靜音規則.png
├── 13-彈窗-事件列表-事件詳情1-基本資訊.png
├── 14-彈窗-事件列表-事件詳情2-處理歷史.png
├── 15-彈窗-事件列表-事件詳情3-關聯事件.png
├── 16-彈窗-事件列表-事件詳情4-自動化.png
├── 17-彈窗-事件列表-AI事件分析報告.png
├── 18-彈窗-事件規則-建立靜音.png
├── 19-彈窗-事件規則-編輯事件規則1-基本資訊.png
├── 20-彈窗-事件規則-編輯事件規則2-觸發條件.png
├── 21-彈窗-事件規則-編輯事件規則3-事件內容.png
├── 22-彈窗-事件規則-編輯事件規則4-自動化.png
├── 23-彈窗-靜音規則-編輯靜音規則1-基本資訊.png
├── 24-彈窗-靜音規則-編輯靜音規則2-設定排程.png
├── 25-彈窗-靜音規則-編輯靜音規則3-設定範圍.png
├── 30-頁面-資源列表.png
├── 31-頁面-資源群組.png
├── 32-頁面-拓撲視圖.png
├── 33-彈窗-資源列表-編輯資源.png
├── 34-彈窗-資源群組-編輯群組.png
├── 40-頁面-儀表板管理.png
├── 41-頁面-基礎設施洞察.png
├── 42-頁面-SRE戰情室.png
├── 50-頁面-容量規劃.png
├── 51-頁面-腳本庫.png
├── 52-頁面-排程管理.png
├── 53-頁面-執行日誌.png
├── 54-彈窗-腳本庫-編輯腳本.png
├── 55-彈窗-排程管理-編輯排程-簡易模式.png
├── 56-彈窗-排程管理-編輯排程-進階模式.png
├── 57-彈窗-執行日誌-執行日誌詳情.png
├── 60-頁面-人員管理.png
├── 61-頁面-團隊管理.png
├── 62-頁面-角色管理.png
├── 63-頁面-審計日誌.png
├── 64-頁面-設定.png
├── 65-彈窗-人員管理-編輯人員.png
├── 66-彈窗-團隊管理-編輯團隊.png
├── 67-彈窗-角色管理-新增角色.png
├── 68-抽屜-審計日誌-日誌詳情.png
├── 70-頁面-通知策略.png
├── 71-頁面-通知管道.png
├── 72-頁面-通知歷史.png
├── 73-彈窗-通知策略-編輯通知策略1.png
├── 74-彈窗-通知策略-編輯通知策略2.png
├── 75-彈窗-通知策略-編輯通知策略3.png
├── 76-彈窗-通知管道-編輯通知管道.png
├── 77-抽屜-通知歷史-通知詳情.png
├── 80-頁面-標籤管理.png
├── 81-頁面-郵件設定.png
├── 82-頁面-身份驗證.png
├── 83-彈窗-標籤管理-新增標籤.png
├── 84-彈窗-標籤管理-管理標籤值.png
├── 85-彈窗-標籤管理-編輯標籤.png
├── 90-頁面-個人資料-個人資訊.png
├── 91-頁面-個人資料-偏好設定.png
└── 92-頁面-個人資料-密碼安全.png
```

## 文件結構

- [全域](#0.全域)
- [事件管理](#1.事件管理)
- [資源管理](#2.資源管理)
- [儀表板](#3.儀表板)
- [分析中心](#4.分析中心)
- [自動化中心](#5.自動化中心)
- [設定-身份與存取管理](#6.設定-身份與存取管理)
- [設定-通知管理](#7.設定-通知管理)
- [設定-平台管理](#8.設定-平台管理)
- [個人資料](#9.個人資料)

## 📋 技術架構與導航
- [🔗 導航結構](#-導航結構)
- [🎯 架構特點](#-架構特點)
- [🎨 UI/UX 設計原則與規範](#-uiux-設計原則與規範)
- [📊 度量指標建議](#-度量指標建議)
- [🚀 發展建議](#-發展建議)
- [📈 實施進度追蹤](#-實施進度追蹤)
- [🎨 設計規範總結](#-設計規範總結)

---

## 0.全域

### 登入 [登入](images/00-頁面-登入.png)

**功能描述**：
- SRE Platform 智慧化系統管理平台的登入頁面
- 簡潔的品牌識別設計，包含平台 Logo 和名稱
- 標準的帳號密碼登入表單，包含帳號輸入框、密碼輸入框（具備顯示/隱藏功能）
- 「記住我」核取方塊和「忘記密碼？」連結
- 主要登入按鈕和版本資訊顯示
- 深色主題設計，符合現代 SRE 工具的專業感

**相關 API 端點**：
- `POST /api/v1/auth/login` - 用戶登入驗證
- `POST /api/v1/auth/forgot-password` - 忘記密碼請求
- `GET /api/v1/auth/session` - 驗證會話狀態
- `POST /api/v1/auth/logout` - 用戶登出

**UX 改善建議**：
1. **多因素認證支援**：增加 2FA/TOTP 等額外安全驗證選項
2. **社交登入整合**：支援企業級 SSO（如 Google Workspace、Microsoft 365、LDAP）
3. **登入狀態記憶**：優化「記住我」功能，提供不同的會話時長選項
4. **錯誤處理優化**：提供清晰的錯誤提示和恢復建議
5. **載入狀態指示**：登入過程中顯示載入動畫，改善用戶體驗
6. **密碼強度指示**：在密碼重設流程中提供強度檢測
7. **可及性改善**：支援鍵盤導航和螢幕閱讀器
8. **行動端適配**：確保在各種螢幕尺寸下的良好體驗

**Jules 的分析與建議**：

我已審閱此分析。此頁面是整個平台的**核心資產庫 (CMDB)**，其設計目標應是將一個靜態的資源清單，轉化為一個**即時、可觀測、可操作的基礎設施管理中樞**。目前的設計是一個絕佳的起點，以下建議旨在深化其架構，使其成為真正的單一事實來源 (SSOT)。

**核心後端架構：動態 CMDB**
1.  **統一資料模型**：後端應建立一個統一的資源資料模型，其資料來源是**多源聚合**的：
    *   **核心 CMDB 資料庫 (PostgreSQL)**：儲存資源的靜態屬性，如 `name`, `ip_address`, `location`, `owner_team`, `resource_type`。這是資源的「身份證」。
    *   **自動化探索工具 (Discovery Tools)**：應定期執行自動化腳本（如 Ansible playbooks 或雲端 API 掃描），探索新的資源或更新現有資源的屬性，並寫入 PostgreSQL。
    *   **監控系統 (VictoriaMetrics)**：即時的性能指標（如 `CPU使用率`、`記憶體使用率`）應從 VictoriaMetrics 動態查詢。
    *   **事件系統 (Event Store)**：`關聯事件` 的數量應從事件儲存中即時聚合。
2.  **高效能 API 設計**：
    *   `GET /api/v1/resources`: 此 API 必須高效。後端服務應在回傳前，非同步地聚合來自上述多個來源的資料。對於列表中的即時指標，可以考慮使用一個稍微延遲（如 1 分鐘）的快取，以平衡即時性與效能。
    *   `GET /api/v1/resources/statistics`: 頂部的四個 KPI 指標**必須**由一個背景排程作業（如每分鐘一次）**預先計算並快取**在 Redis 中。此 API 應直接讀取快取，確保頁面毫秒級載入。
    *   `GET /api/v1/resources/{id}/metrics?range=1h`: 應提供一個專門的端點，用於獲取資源在特定時間範圍內的詳細時序數據，供前端的迷你圖表使用。

**UX/UI 強化建議：將資料轉化為洞察**
1.  **將指標視覺化為趨勢**：目前的 `CPU` 和 `記憶體使用率` 條狀圖只顯示了當前時間點的快照。應將其升級為**迷你趨勢圖 (Sparkline Chart)**，展示過去一小時的變化趨勢。這能讓 SRE 快速判斷問題是瞬時尖峰還是持續高負載。
2.  **標籤即是操作的起點 (Tag-Driven Operations)**：
    *   **標籤必須是可點擊的**：UI 中的每一個標籤（如 `production`, `database`）都應是一個超連結。點擊後，頁面會以此標籤為篩選條件，重新載入資源列表。
    *   **批次操作以標籤為中心**：「批次設定」功能的核心應該是**批次編輯標籤**，允許 SRE 一次性為多個資源打上或移除同一個標籤。
3.  **增強的健康狀態指示**：
    *   **解釋「為何」**：滑鼠懸停在「狀態」圖示（如 `警告`）上時，必須顯示一個工具提示 (Tooltip)，清晰地說明觸發此狀態的**具體原因**，例如「`cpu_usage > 80% for 5m`」。此資訊直接來自觸發告警的規則。
    *   **關聯事件連結**：`關聯事件` 欄位的數字不僅是數字，更應是一個**可點擊的連結**。點擊後，應彈出一個 Modal 或跳轉到一個預先篩選好的事件列表頁面，只顯示與該資源直接相關的活躍事件。
4.  **情境化的行內操作 (Contextual Actions)**：表格最右側的「操作」按鈕不應是固定的。應根據資源的 `類型` 和 `標籤` 動態顯示。例如：
    *   `類型: database` 的資源，可以顯示「執行備份」、「查看慢查詢」等操作。
    *   `類型: kubernetes-pod` 的資源，可以顯示「查看日誌」、「進入容器 (Exec)」等操作。
    這需要後端設計一個靈活的 `actions` API，根據資源屬性回傳可用的操作列表。

### 使用者選單 [使用者選單](images/01-彈窗-使用者選單.png)

**功能描述**：
- 點擊頂部導航列右側的使用者頭像時顯示的下拉選單。
- 顯示當前登入使用者的名稱和電子郵件。
- 提供導向「個人資料」、「幫助中心」的連結及「登出」功能。

**相關 API 端點**：
- `GET /api/v1/users/me` - 獲取當前登入使用者的詳細資訊。
- `POST /api/v1/auth/logout` - 執行使用者登出操作。

**UX 改善建議**：
1. **新增角色顯示**：在使用者名稱下方顯示其角色（如：管理員），有助於快速辨識身份與權限。
2. **加入主題切換**：若系統支援多種主題（如深色/淺色模式），可在此處增加快速切換開關。
3. **鍵盤可及性**：確保選單內所有選項均可透過鍵盤（Tab、Enter）進行導覽與操作。
4. **幫助中心新開分頁**：點擊「幫助中心」應在新瀏覽器分頁中開啟，避免使用者中斷當前作業流程。

**Jules 的分析與建議**：

我已審閱此分析，這些關於 API Payload 設計和 UX 功能強化的建議，對於將此選單從一個簡單的導航工具，提升為 SRE 的高效工作入口至關重要。我完全贊同以下觀點：

這個使用者選單是平台個人化和情境感知的核心入口，其設計應專注於效率和資訊密度，以滿足 SRE 的專業需求。

**API 設計與 Payload 關鍵**：
1.  **`GET /api/v1/users/me` - 豐富化 Payload**：此 API 是前端權限控制和個人化顯示的基石。其回傳的 JSON 物件**必須**一次性包含所有關鍵資訊，避免前端多次請求：
    *   `id`, `name`, `email`, `avatar_url`
    *   `roles`: 使用者所屬的角色陣列 (e.g., `["Admin", "TeamLead"]`)
    *   `teams`: 使用者所屬的團隊列表
    *   `permissions`: 一個包含所有有效權限的扁平化字串陣列，供前端進行快速、高效的權限檢查 (e.g., `["event:read", "event:update"]`)。
    *   `preferences`: 使用者的個人偏好設定，如 `theme` (`"dark"`, `"light"`)。
    *   `on_call_status`: (推薦) 與 Grafana OnCall 同步的值班狀態 (`"on-call"`, `"off-call"`)。
2.  **`POST /api/v1/auth/logout` - 徹底的單一登出 (SLO)**：此 API 必須觸發完整的 Keycloak SLO 流程，確保使用者在所有關聯系統中都完全登出，這是企業級安全的基本要求。

**UX 功能強化建議**：
1.  **強化情境感知 (Context Awareness)**：在使用者 Email 下方，直接顯示其**主要角色**和**所屬團隊**。這能讓使用者在執行任何操作前，對自己的權限上下文一目了然。
2.  **整合值班狀態 (On-Call Status)**：在頂部導覽列的使用者名稱旁，增加一個與 `on_call_status` 關聯的**視覺指示燈**。例如，值班中顯示紅色，非值班顯示綠色。將此狀態與通知系統聯動，是極具價值的 SRE 團隊協作功能。
3.  **提供 SRE 專屬捷徑 (SRE-Specific Shortcuts)**：
    *   **API 金鑰管理**：增加「**管理 API 金鑰**」的直接連結，導向個人存取權杖 (PAT) 管理頁面。
    *   **快速複製使用者ID**：在使用者 Email 旁增加一個「複製」圖示，允許一鍵複製其 UUID。這對於在日誌中搜尋操作記錄或在 API 中進行調試非常實用。
4.  **高效的主題切換**：在選單底部（登出之上）增加一個分段控制器 (Segmented Control)，提供「淺色」、「深色」、「系統預設」三個選項，讓使用者可以快速切換 UI 主題，並將選擇持久化到後端的 `preferences`。

### 通知中心 [通知中心](images/02-彈窗-通知中心.png)

**功能描述**：
- 點擊頂部導航列的通知鈴鐺圖示時顯示的下拉面板。
- 顯示最近的通知列表，並以圖示區分不同類型（如：錯誤、資訊、警告、成功）。
- 每則通知包含標題、簡述及時間戳。
- 提供「全部已讀」和「查看所有通知」的快捷操作。
- 通知圖示上的徽章顯示未讀通知的數量。

**相關 API 端點**：
- `GET /api/v1/notifications?limit=5&unread=true` - 獲取用於預覽的最新未讀通知。
- `GET /api/v1/notifications/count?unread=true` - 獲取未讀通知的總數，用於更新徽章。
- `POST /api/v1/notifications/mark-all-as-read` - 將所有通知標記為已讀。
- `POST /api/v1/notifications/{id}/read` - 將單一通知標記為已讀（例如，在點擊後）。

**UX 改善建議**：
1. **分類篩選**：增加通知類型篩選（錯誤、警告、資訊、成功），方便快速查找特定類型通知
2. **批次操作**：支援批次標記已讀和批次刪除功能
3. **通知預覽**：hover 時顯示通知完整內容預覽
4. **即時更新**：使用 WebSocket 實現通知的即時推送和狀態更新
5. **優先級排序**：高優先級通知應在列表頂部突出顯示
6. **通知歷史**：提供完整的通知歷史記錄和搜尋功能
7. **自定義設定**：允許用戶自訂通知偏好和頻率設定
8. **操作追蹤**：記錄用戶對通知的操作（已讀、忽略、回應等）

**Jules 的分析與建議**：

我已審閱此分析。將通知中心從一個被動的資訊列表，升級為一個具備**即時性、可操作性和降噪能力**的主動控制台，是提升平台核心價值的關鍵。以下分析中的後端架構和 UX 建議是實現此目標的正確藍圖。

通知中心不僅是資訊的展示板，更應是 SRE 高效工作的「儀表盤」和「控制台」。其設計應圍繞**即時性**、**可操作性**和**降噪**三大核心原則。

**後端架構與 API 設計**：
1.  **非同步與解耦**：後端應建立一個獨立的 `Notification` 服務。所有其他服務（事件、自動化等）不應直接寫入通知，而是將通知請求發布到一個**訊息佇列 (Message Queue)**，如 Redis Streams 或 RabbitMQ。`Notification` 服務作為唯一的消費者，負責處理、儲存並分派通知。此架構能確保核心業務流程的高效能與服務間的松耦合。
2.  **即時推送 (Real-time Push)**：後端必須提供一個 WebSocket 端點 (e.g., `/ws/v1/notifications`)。使用者連線後，`Notification` 服務可將新通知即時推送至前端，實現徽章數字和列表的動態更新，這對於作戰室場景至關重要。
3.  **強化的查詢 API**：`GET /api/v1/notifications` API 應支援豐富的查詢參數，除了分頁，還應至少支援按 `status` (`read`, `unread`)、`type` (`error`, `info`, `warning`, `success`) 和 `priority` (`high`, `medium`, `low`) 進行伺服器端篩選。

**UX 功能強化建議**：
1.  **可操作的通知 (Actionable Notifications)**：這是最重要的 UX 提升。每一條通知，特別是告警類通知，都應附帶一組**情境相關的快捷操作按鈕**。例如：
    *   `CPU high on db-prod-01` 通知應附帶：「**查看資源儀表板**」、「**建立靜音規則**」、「**指派給自己**」。
    *   `Script "..." executed` 通知應附帶：「**查看執行日誌**」。
    這能將通知中心從一個「唯讀」面板，轉變為一個高效的「工作入口」。
2.  **智慧降噪 (Intelligent Noise Reduction)**：
    *   **智慧分組**：當短時間內（如 1 分鐘內）收到超過 3 條來自同一資源的同類告警時，系統應自動將其合併為一條可展開的通知，例如「**[db-prod-01] 在 1 分鐘內有 5 條 CPU 過高告警**」，避免「告警風暴」淹沒使用者介面。
    *   **精細化偏好設定**：在「查看所有通知」的完整頁面中，應提供一個強大的設定介面，讓使用者可以**針對不同類型、不同優先級的通知，自訂其接收管道**（如：P1 告警發送簡訊和 App 推送，P3 告警僅在站內顯示）。賦予使用者控制噪音的權力是提升平台滿意度的關鍵。

---

## 1.事件管理

### 事件列表 [事件列表](images/10-頁面-事件列表.png)

**功能描述**：
- 統一事件管理介面
- 事件統計 KPI：活躍事件、今日已解決、平均解決時間、自動化處理率
- 事件列表表格：嚴重性、摘要、資源名稱、業務影響、狀態、處理人、觸發時間
- 批次操作和篩選功能
- AI 分析功能

**相關 API 端點**：
- `GET /api/v1/events` - 獲取事件列表（支援分頁、篩選、排序）
- `GET /api/v1/events/{id}` - 獲取事件詳情
- `PUT /api/v1/events/{id}/assign` - 分配事件處理人
- `PUT /api/v1/events/{id}/status` - 更新事件狀態
- `POST /api/v1/events/batch-update` - 批次更新事件
- `GET /api/v1/events/statistics` - 事件統計數據
- `POST /api/v1/events/{id}/ai-analysis` - 觸發 AI 分析

**UX 改善建議**：
1. **狀態視覺化**：使用色彩編碼和圖示更清楚地表示事件嚴重性和狀態
2. **快速操作**：在表格行內增加快捷操作按鈕（確認、分配、關閉）
3. **智能篩選**：增加預設篩選器（如「我的事件」、「高優先級」等）
4. **時間軸視圖**：提供事件時間軸視圖選項
5. **批次操作優化**：改善批次操作 UI，提供更清楚的選中狀態和操作反饋

**Jules 的分析與建議**：

我已審閱此分析。將事件列表從一個簡單的資料表，轉變為一個整合了**高效數據流、高性能 API 和即時互動體驗**的決策支援中心，是本平台成功的關鍵。此處的架構和建議是實現這一目標的堅實基礎。

事件列表是 SRE 平台的核心作戰室，其設計目標應是**將海量、雜亂的告警，轉化為清晰、可操作、有上下文的事件**。這不僅是一個列表，更是一個決策支援系統。

**核心後端架構與 API 設計**：
1.  **資料接收與處理流程 (Webhook -> Kafka -> Go Service)**：
    *   後端應提供一個高度可用的 Webhook 端點 (e.g., `POST /api/v1/webhooks/grafana`)，它只做一件事：快速接收原始告警，驗證後立即寫入 **Kafka** 或 Redis Streams。
    *   一個獨立的 Go **事件處理服務 (Event Processor)** 會消費這些原始告警。它負責：(a) **去重**；(b) **告警風暴檢測** (e.g., 1分鐘內超過N筆同類告警)；(c) 呼叫 **AI 分析服務**進行根因、關聯、影響等分析；(d) 將豐富化後的事件存入 **PostgreSQL** (用於結構化查詢) 和 **Elasticsearch** (用於全文檢索和複雜篩選)。
2.  **API 設計要點**：
    *   `GET /api/v1/events/statistics`：頂部的四個 KPI 指標（活躍事件、MTTR 等）**必須**由一個背景排程作業（如每分鐘執行一次）**預先計算並快取**在 Redis 中。此 API 應直接讀取快取，以確保頁面毫秒級載入。
    *   `GET /api/v1/events`：此 API 的後端實現應主要查詢 **Elasticsearch**。除了支援基於欄位的結構化篩選（如 `status=NEW`），還應在主搜尋框中支援**強大的查詢字串語法**（如 Lucene query string），允許 SRE 進行 `summary:(error OR 503) AND NOT resource_name:staging-*` 這類複雜的即時查詢。
    *   `PUT /api/v1/events/{id}/status`：更新事件狀態（如 `ACK`）時，後端應考慮透過 API **雙向同步**回 Grafana Alerting，確保兩個系統的狀態一致。

**UX/UI 強化建議**：
1.  **動態與即時的列表**：列表應透過 **WebSocket** 實現即時更新。新進事件應有短暫的**高亮動畫**，狀態變更（如 `NEW` -> `ACK`）也應有視覺提示，為 SRE 打造一個真正的「即時」作戰室。
2.  **告警風暴的視覺化處理**：圖片中已有的「風暴」標籤是個很好的開始。應將其強化：
    *   **視覺合併**：處於風暴中的事件應在 UI 上自動**摺疊為一組**，僅顯示摘要和數量，點擊後才展開詳情，避免畫面被淹沒。
    *   **專屬操作**：為風暴事件組提供專屬的批次操作，如「**批次靜音**」、「**合併為事故**」。
3.  **可自訂的視圖 (Custom Views)**：除了現有的篩選器，應允許使用者將一組複雜的篩選條件**儲存為個人化的「視圖」**，例如「我的 P1 事件」、「資料庫團隊相關事件」，並能快速切換。這是提升高階使用者操作效率的關鍵功能。
4.  **「業務影響」的來源與視覺化**：表格中的「業務影響」欄位（高、中、低）是關鍵決策資訊。UI 上應提供工具提示(tooltip)，說明此影響等級的判斷依據（例如，來源於關聯資源的 `criticality` 標籤）。此外，應考慮使用除了顏色之外的形狀或圖示來標示，以改善色盲人士的可及性。
5.  **情境化的行內操作 (Contextual Row Actions)**：對於「操作」欄，不應總是顯示相同的按鈕。應根據事件的 `status` 和 `type` 動態顯示最相關的操作。例如：
    *   對於 `status: NEW` 的事件，主要操作是「**確認 (Ack)**」和「**靜音**」。
    *   對於 `status: ACK` 的事件，主要操作應變為「**解決 (Resolve)**」和「**分配 (Assign)**」。
    *   純圖示按鈕應在滑鼠懸停時提供明確的文字提示 (Tooltip)，確保其意圖清晰。

#### 事件詳情彈窗 - 基本資訊 [事件詳情1-基本資訊](images/13-彈窗-事件列表-事件詳情1-基本資訊.png)

**功能描述**：
- 事件詳情彈窗的「基本資訊」頁籤
- 顯示事件的核心屬性：摘要、嚴重性、狀態、來源、觸發時間、關聯資源與規則
- 提供快速操作連結和底部的主要操作按鈕

**相關 API 端點**：
- `GET /api/v1/events/{id}` - 獲取單一事件的完整詳細資訊

**UX 改善建議**：
1. **資訊層次優化**：使用視覺層次和色彩編碼突出重要資訊（嚴重性、狀態）
2. **快捷操作按鈕**：在彈窗中添加常用操作的快捷按鈕（分配、確認、忽略）
3. **關聯資源導航**：點擊關聯資源應能直接跳轉到資源詳情頁面
4. **複製分享功能**：提供事件資訊的快速複製和分享功能
5. **標籤管理**：支援為事件添加自定義標籤，便於分類和追蹤

**Jules 的分析與建議**：

我已審閱此彈窗設計與現有分析。此彈窗是事件處理的「主控台」，其設計必須嚴格遵循「單一事實來源 (Single Source of Truth)」原則，為 SRE 提供所有必要的上下文和操作入口。現有分析中的 API 設計方向是正確的，我將其進一步強化，確保與 `docs/architecture.md` 中定義的架構完全對齊。

**API 設計原則：一次性全量獲取，語義化狀態變更**

1.  **`GET /api/v1/events/{id}` - 全量資料 Payload**:
    此 API 的設計至關重要。為確保彈窗內各分頁（處理歷史、關聯事件等）的流暢切換，它**必須**在一次請求中回傳該事件的**所有**相關資訊。其 Payload 應被良好地結構化、版本化，並在 `openapi.yaml` 中詳細記錄。

    *   **Payload 結構範例**:
        ```json
        {
          "id": "evt_2a7d3e9f-8b4c-4f1a-9e2d-6c1f8a7b3e9f",
          "summary": "CPU high on db-mysql-prod-02",
          "severity": "CRITICAL",
          "status": "ACKNOWLEDGED",
          "source": "Prometheus",
          "triggered_at": "2025-09-18T11:11:43Z",
          "acknowledged_at": "2025-09-18T11:15:01Z",
          "resolved_at": null,
          "assignee": {
            "id": "usr_1a2b3c",
            "name": "陳大文"
          },
          "resource": {
            "id": "res_b4c5d6",
            "name": "db-mysql-prod-02",
            "type": "DATABASE",
            "cmdb_link": "/resources/res_b4c5d6"
          },
          "rule": {
            "id": "rule_e7f8g9",
            "name": "高 CPU 使用率"
          },
          "trigger_details": {
            "threshold": "CPU > 90%",
            "value": "92.5%"
          },
          "tags": [
            { "key": "env", "value": "production", "color": "#f5222d" },
            { "key": "dc", "value": "asia-east1", "color": "#faad14" },
            { "key": "service", "value": "user-database", "color": "#52c41a" }
          ],
          "quick_links": [
            { "name": "資源儀表板", "url": "https://grafana.example.com/d/abc-123/db-mysql-prod-02" },
            { "name": "相關日誌", "url": "https://loki.example.com/explore?query={...}" },
            { "name": "維運手冊 (Runbook)", "url": "https://confluence.example.com/kb/runbook-cpu-high" }
          ],
          "available_actions": [
            { "key": "resolve", "label": "解決 (Resolve)", "api_endpoint": "/api/v1/events/{id}/status", "method": "PUT", "payload": { "status": "resolved" } },
            { "key": "assign", "label": "指派 (Assign)", "api_endpoint": "/api/v1/events/{id}/assign", "method": "PUT" },
            { "key": "silence", "label": "建立靜音", "api_endpoint": "/api/v1/silence-rules", "method": "POST" }
          ],
          // 以下是為其他分頁預載的資料
          "history_logs": [ /* ... 處理歷史資料 ... */ ],
          "related_events": [ /* ... 關聯事件資料 ... */ ],
          "automation_runs": [ /* ... 自動化執行資料 ... */ ]
        }
        ```

2.  **語義化的狀態變更 API**:
    底部的操作按鈕應完全由 API 回應中的 `available_actions` 陣列驅動。例如，「確認收到 (Ack)」按鈕（在此例中應為禁用狀態，因為事件已確認）應呼叫 `PUT /api/v1/events/{id}/status` 並附帶語義化的請求體 `{ "status": "acknowledged" }`，而非一個通用的 `update` 端點。這使得後端可以為每個狀態轉換觸發特定的業務邏輯（如記錄歷史、通知相關人員）。

**UX/UI 強化建議**：
1.  **標籤 (Tags) 必須成為一等公民**：在「基本資訊」中，所有從 Grafana 繼承的標籤都應被**顯著地、可點擊地、帶有色彩地**展示出來。點擊標籤應能快速跳轉到事件列表，並以此標籤作為篩選條件。這是 SRE 進行問題定位和模式分析時最高頻的操作之一。
2.  **萬物皆可連結 (Everything is a Link)**：為實現深度追溯，此視圖中的每一個實體（資源名稱、規則名稱、來源、處理人等）都**必須**是一個超連結，導向其對應的管理或詳情頁面，讓 SRE 可以無縫地進行鑽取式分析 (drill-down)。**特別是「資源名稱」，它應連結至平台內部的資源管理頁面 (`/resources/{id}`), 而非外部系統。**
3.  **數據驅動的「快速操作」**：此區塊應完全由 API 回應中的 `quick_links` 陣列動態產生。這使得管理員可以根據事件來源或標籤，靈活配置最有用的外部連結（如監控圖表、日誌系統、Runbook 等），而無需在前端硬編碼。
4.  **賦予「AI 分析」更明確的價值**：點擊「AI 分析」按鈕後，不應僅僅是跳轉，而應在當前彈窗內**非同步地載入分析結果**，並在完成後用一個小紅點或動畫提示使用者查看。分析結果應直接呈現在一個新的「AI 分析」分頁中，內容包括**根因猜測**、**影響半徑**和**建議的處理步驟**。

#### 事件詳情彈窗 - 處理歷史 [事件詳情2-處理歷史](images/14-彈窗-事件列表-事件詳情2-處理歷史.png)

**功能描述**：
- 事件詳情彈窗的「處理歷史」頁籤
- 以垂直時間軸的形式呈現事件生命週期
- 每一個歷史節點包含狀態、操作描述、執行者及時間戳

**相關 API 端點**：
- `GET /api/v1/events/{id}/history` - 獲取指定事件的處理歷史記錄

**UX 改善建議**：
1. **時間軸視覺化**：使用更豐富的時間軸設計，包含狀態圖示和進度指示
2. **詳細資訊展開**：支援點擊展開查看每個操作的詳細資訊和影響
3. **操作人員資訊**：顯示操作人員的頭像、角色和聯絡方式
4. **操作耗時統計**：顯示每個處理階段的耗時，幫助優化流程
5. **匯出功能**：支援將處理歷史匯出為 PDF 或其他格式
6. **相關事件連結**：當歷史中涉及其他事件時，提供快速跳轉連結

**Jules 的分析與建議**：

我已審閱此設計。處理歷史不僅是日誌，更是**團隊協作、知識沉澱和事後複盤 (Postmortem)** 的核心。其設計應圍繞**資訊結構化**和**高效協作**兩個中心。現有的分析已為此奠定了堅實的基礎，我將在此之上，進一步深化其後端架構設計，確保其健壯性與可擴展性。

**後端資料模型與 API 設計**：

1.  **`event_histories` 資料模型**：
    後端應設計一張專門的 `event_histories` 表來記錄事件生命週期中的所有活動。其核心欄位必須定義清晰：
    *   `id`: 歷史條目的唯一識別碼。
    *   `event_id`: 關聯事件的 foreign key。
    *   `type`: **(關鍵欄位)** 用於區分條目類型的枚舉，以便前端進行差異化渲染。
        *   `SYSTEM_STATE_CHANGE`: 系統觸發的狀態變更，如 `NEW` -> `ACKNOWLEDGED`。
        *   `USER_COMMENT`: 使用者手動新增的評論。
        *   `AUTOMATION_RUN`: 自動化腳本的執行記錄。
        *   `ASSIGNEE_CHANGE`: 事件被指派給新的使用者或團隊。
    *   `actor`: 執行操作的實體，格式應為 `type:id`，如 `"system:prometheus"`, `"user:usr_1a2b3c"`, `"rule:rule_e7f8g9"`。
    *   `content`: 主要的文字內容，**必須支援 Markdown**。對於狀態變更，可以是「狀態由 NEW 變更為 ACKNOWLEDGED」。
    *   `metadata`: 一個 `JSONB` 欄位，用於儲存結構化資料。例如，對於 `USER_COMMENT`，可以儲存 `attachments` 陣列；對於 `AUTOMATION_RUN`，可以儲存 `execution_id` 和 `exit_code`。
    *   `created_at`: 條目的時間戳。

2.  **`GET /api/v1/events/{id}` - `history_logs` Payload**:
    此資料應作為主事件 API 的一部分一次性載入，以避免額外的網路請求。

    ```json
    "history_logs": [
      {
        "id": "hist_001",
        "type": "SYSTEM_STATE_CHANGE",
        "actor": { "type": "system", "name": "Prometheus" },
        "content": "事件建立",
        "created_at": "2025-09-18T11:11:43Z",
        "metadata": null
      },
      {
        "id": "hist_002",
        "type": "USER_COMMENT",
        "actor": { "type": "user", "id": "usr_2", "name": "user_2", "avatar_url": "..." },
        "content": "已確認，正在分析和處理問題。",
        "created_at": "2025-09-18T11:13:43Z",
        "metadata": {
          "attachments": [
            { "file_name": "cpu_graph.png", "url": "/files/cpu_graph.png" }
          ]
        }
      }
    ]
    ```

3.  **語義化的評論與通知 API (`POST /api/v1/events/{id}/comments`)**:
    *   **後端邏輯**: 收到請求後，後端會在 `event_histories` 表中建立一筆 `type: USER_COMMENT` 的紀錄。接著，為了實現服務解耦，它**不應直接呼叫通知服務**，而是應該：
        1.  解析 `content` 中的 `@提及` (如 `@陳大文` 或 `@DBA_Team`)。
        2.  將一個結構化的「提及通知」事件發布到**訊息佇列 (Message Queue)**，如 Kafka 或 Redis Streams。
        3.  由獨立的 `Notification` 服務消費此訊息，並負責向被提及的對象發送精準通知。此模式確保了事件評論功能的高效能與系統的整體健壯性。

4.  **附件處理流程 (Attachment Handling Flow)**:
    *   為支援附件上傳，前端應呼叫一個專門的**檔案服務**端點 (e.g., `POST /api/v1/files`)，該服務負責將檔案儲存至物件儲存 (如 S3) 並回傳一個 `file_id`。
    *   當使用者發表評論時，這個 `file_id` 會被包含在 `POST /api/v1/events/{id}/comments` 的請求體中，後端僅需儲存此 ID，而非處理檔案本身。

**UX/UI 強化建議**：

1.  **富文本與附件支援 (Rich Text & Attachments)**：評論輸入框**必須**是一個**支援 Markdown 的富文本編輯器**，並提供**上傳附件**（如截圖、日誌片段）的功能。這對於準確、完整地記錄問題排查過程至關重要。
2.  **視覺化區分資訊類型 (Visually Distinguish Entry Types)**：在時間軸的視覺設計上，必須明確區分不同 `type` 的歷史記錄。例如：
    *   **系統狀態變更**：使用簡潔、中性的系統圖示（如齒輪）。
    *   **使用者評論**：**顯示該使用者的頭像**，使人為干預的資訊在時間軸中脫穎而出。
    *   **自動化執行**：使用一個「機器人」圖示。
    這種視覺區分能幫助使用者快速掃描和定位關鍵的人為干預和評論資訊。
3.  **篩選與搜尋 (Filter and Search)**：對於冗長的處理歷史，在頂部增加**篩選控制項**（例如，一個可以多選 `type` 的下拉選單，只看「使用者評論」和「指派變更」）和一個**搜尋框**，是**不可或缺**的功能。這能讓 SRE 在複雜事件中快速定位關鍵資訊。
4.  **將歷史轉化為知識 (Transform History into Knowledge)**：提供一個「**新增至知識庫**」或「**匯出為複盤報告**」的功能。使用者可以勾選幾條關鍵的處理歷史後，一鍵將這些結構化的資訊（操作者、時間、內容、附件）匯出，作為未來處理類似問題的 SOP 或事後學習材料，實現知識的沉澱與轉化。

#### 事件詳情彈窗 - 關聯事件 [事件詳情3-關聯事件](images/15-彈窗-事件列表-事件詳情3-關聯事件.png)

**功能描述**：
- 事件詳情彈窗的「關聯事件」頁籤
- 顯示系統根據時間、資源、拓撲或AI分析判斷出的相關事件列表

**相關 API 端點**：
- `GET /api/v1/events/{id}/related` - 獲取與指定事件相關的事件列表

**UX 改善建議**：
1. **關聯度評分**：顯示每個相關事件的關聯度評分和關聯原因
2. **視覺化關係圖**：提供事件關係的網絡圖或樹狀圖視覺化
3. **智能分組**：按關聯類型（時間、資源、拓撲、AI 推薦）自動分組
4. **批次操作**：支援對相關事件的批次操作（批次確認、分配等）
5. **根因分析**：整合 AI 分析，識別可能的根本原因事件
6. **事件鏈追蹤**：顯示事件的完整影響鏈和傳播路徑

**Jules 的分析與建議**：

我已審閱此設計。關聯分析是從「單點告警」邁向「系統性故障分析」的關鍵一步，是實現告警降噪、凸顯故障傳播鏈的核心功能。此處的目標是提供一個**自動化的決策支援工具**，最終引導 SRE 將一組相關的低階事件，合併為一個需要集中處理的高階**「事故 (Incident)」**。

**後端架構與 API 設計**：

1.  **「事故 (Incident)」抽象層**:
    *   為管理一組關聯事件，後端必須引入一個更高層級的**「事故 (Incident)」資料模型**。這是從被動響應轉向主動管理的關鍵。
    *   `incidents` 表應包含 `title`, `status`, `severity`, `assignee_id` 等欄位，並透過一個關聯表 (e.g., `incident_events`) 連結多個 `event_id`。
    *   `POST /api/v1/incidents`: 此 API 用於**事件合併**或**事故升級**。
        *   **Request Body**:
            ```json
            {
              "title": "資料庫效能下降事故",
              "severity": "CRITICAL",
              "assignee_id": "usr_1a2b3c",
              "event_ids": ["evt_2a7d3e9f", "evt_aaa", "evt_bbb"]
            }
            ```
        *   **後端邏輯**: 建立 `incident` 記錄後，後端應將所有傳入的 `event_ids` 對應的事件狀態更新為 `MERGED`，並將它們從主要的事件列表中過濾掉，以達到降噪目的。

2.  **非同步關聯引擎 (Async Correlation Engine)**：
    *   為找出哪些事件應被關聯，後端 AI 服務的核心是一個**非同步的關聯引擎**。當新事件被處理時，該引擎會被觸發，基於多種策略進行計算：
        *   **時間關聯 (Time Correlation)**: 事件在極短時間窗口內發生。
        *   **拓撲關聯 (Topology Correlation)**: 基於 CMDB 中的服務依賴關係（上游/下游）。
        *   **內容關聯 (Content Correlation)**: 基於事件標籤或摘要的相似性。
        *   **機器學習 (Machine Learning)**: 基於歷史數據學習到的共現模式。
    *   計算結果——包含關聯的 `event_id`、**關聯類型** (`type`) 和**置信度** (`confidence`)——必須被**預先計算並儲存**在一張專門的 `event_correlations` 表中。

3.  **`GET /api/v1/events/{id}` - `related_events` Payload**:
    此 API **絕不能**即時計算關聯性，而應直接查詢預先計算好的 `event_correlations` 表，以保證彈窗的快速響應。其回傳的 `related_events` 陣列應有清晰的結構，包含關聯的原因和置信度。

    ```json
    "related_events": [
      {
        "id": "evt_aaa",
        "summary": "API latency over 500ms",
        "severity": "WARNING",
        "status": "ACKNOWLEDGED",
        "triggered_at": "2025-09-18T11:08:43Z",
        "correlation_reason": {
          "type": "TOPOLOGY_DOWNSTREAM",
          "description": "此服務是 db-mysql-prod-02 的下游依賴。",
          "confidence_score": 0.95
        }
      }
      // ... more related events
    ]
    ```

**UX/UI 強化建議**：

1.  **將事件群組提升為「事故」 (Elevate Group to Incident)**: 這是此分頁的**核心工作流程**。
    *   **UI 設計**: 必須為每個關聯事件提供**核取方塊**，並在底部提供一個醒目的「**合併為事故**」按鈕。此按鈕在沒有選中任何事件時應為禁用狀態，其文字應動態更新以反映選中數量，例如「**合併 3 個事件為事故**」。
    *   **操作流程**: 點擊後，彈出一個新對話框，讓使用者為新事故命名、設定嚴重等級和指派處理人，並提供基於關聯事件智慧生成的合理預設值。

2.  **解釋「為何相關」 (Explain "Why")**: 這是建立使用者信任的關鍵。UI 不能只是一個列表。必須在每個關聯事件旁，用一個**清晰的圖示和文字標籤**來解釋其關聯依據（例如，拓撲圖示 +「下游服務」，時鐘圖示 +「時間相近 (1m內)」，AI 圖示 +「AI 推薦 (92%)」）。滑鼠懸停在標籤上時，應有工具提示 (Tooltip) 顯示完整的 `description`。

3.  **視覺化拓撲捷徑 (Visual Topology Shortcut)**: 當關聯原因是 `TOPOLOGY_DOWNSTREAM` 或 `TOPOLOGY_UPSTREAM` 時，應在該條目旁顯示一個「檢視拓撲」的圖示按鈕。點擊後，在彈窗內開啟一個小型的、聚焦的拓撲圖，高亮顯示相關節點和推測的故障路徑。這遠比純文字列表直觀。

#### 事件詳情彈窗 - 自動化 [事件詳情4-自動化](images/16-彈窗-事件列表-事件詳情4-自動化.png)

**功能描述**：
- 事件詳情彈窗的「自動化」頁籤
- 顯示與此事件相關聯的自動化腳本執行情況

**相關 API 端點**：
- `GET /api/v1/events/{id}/automations` - 獲取針對此事件已執行的自動化歷史

**UX 改善建議**：
1. **執行狀態視覺化**：使用進度條和狀態圖示清楚顯示自動化執行狀態
2. **輸出日誌預覽**：提供自動化腳本輸出日誌的快速預覽和完整查看
3. **重新執行功能**：支援對失敗的自動化任務進行重新執行
4. **參數調整**：允許在重新執行時調整自動化參數
5. **影響評估**：顯示自動化執行對事件狀態和系統的影響
6. **執行時間分析**：提供自動化執行時間的統計和優化建議

**Jules 的分析與建議**：

我已審閱此設計。此分頁旨在將「偵測」與「修復」閉環，現有的分析已準確地指出了其核心目標：必須無縫地融合過去的執行記錄與未來的操作可能性，將一個簡單的日誌轉變為互動式的控制台。以下經我確認並強化的設計是實現此目標的正確藍圖。

**後端架構與 API 設計**：

1.  **數據模型關聯**: 後端的 `execution_logs` 表**必須**有一個可為空的 `event_id` 欄位，用以清晰地關聯某次自動化執行與觸發它的事件。

2.  **API 設計 - 分離「已執行」與「推薦」**:
    此分頁的資料應來自兩個平行的、獨立的 API 呼叫，以優化載入體驗。

    *   **已執行記錄**: `GET /api/v1/events/{id}/automation-runs`
        此 API 用於獲取已針對此事件執行的自動化歷史。
        ```json
        {
          "automation_runs": [
            {
              "run_id": "exec_123",
              "script_id": "scr_abc",
              "script_name": "清除 /tmp 目錄空間",
              "status": "SUCCESS",
              "triggered_by": "rule:rule_e7f8g9",
              "started_at": "2025-09-18T11:12:05Z",
              "duration_ms": 15300,
              "summary_log": "成功釋放 1.5GB 磁碟空間。"
            }
          ]
        }
        ```

    *   **推薦的自動化**: `GET /api/v1/events/{id}/recommended-automations`
        此 API 由 AI 代理驅動，它分析事件的上下文（標籤、摘要等），並從腳本庫中推薦最相關的腳本。
        ```json
        {
          "recommended_automations": [
            {
              "script_id": "scr_def",
              "script_name": "重啟資料庫連接池",
              "description": "適用於資料庫連線錯誤相關事件。",
              "confidence_score": 0.85
            },
            {
              "script_id": "scr_ghi",
              "script_name": "分析慢查詢日誌",
              "description": "適用於 CPU 或資料庫延遲事件。",
              "confidence_score": 0.78
            }
          ]
        }
        ```

3.  **手動觸發 API**:
    *   `POST /api/v1/scripts/{script_id}/execute`
    *   此 API 允許使用者從 UI 手動觸發一個腳本。
    *   **Request Body**:
        ```json
        {
          "context": {
            "event_id": "evt_2a7d3e9f"
          },
          "parameters": {
            "target_host": "db-mysql-prod-02",
            "force_mode": false
          }
        }
        ```

**UX/UI 強化建議**：

1.  **讓空狀態變得智慧且可操作 (Make the Empty State Smart & Actionable)**:
    目前的空狀態是個死胡同，應將其重新設計為一個發射台。
    *   **無執行記錄，但有推薦**: 主要視圖應直接顯示**推薦的自動化腳本列表**，每個推薦項旁都有一個「執行」按鈕。
    *   **無執行記錄，亦無推薦**: UI 應顯示「此事件未觸發自動化腳本，也未找到推薦腳本。」，並緊隨兩個明確的行動呼籲 (Call-to-Action) 按鈕：「**手動執行腳本**」（開啟一個搜尋對話框以選擇腳本）和「**設定自動化規則**」（導航至事件規則建立頁面，並預先填入當前事件的上下文）。

2.  **豐富化的執行記錄 (Rich Execution History)**:
    當 `automation_runs` 列表不為空時，每個條目都應是一個可展開的元件。
    *   **收合視圖**: 顯示關鍵資訊：腳本名稱、狀態圖示、觸發原因和時間戳。
    *   **展開視圖**: 點擊後展開，並以分頁顯示更詳細的資訊：
        *   **摘要 (Summary)**: 顯示 `summary_log`。
        *   **參數 (Parameters)**: 顯示此次執行的具體參數。
        *   **完整日誌 (Full Log)**: 顯示完整的、可搜尋的執行日誌輸出。
        *   **操作 (Actions)**: 提供一個「**重新執行**」按鈕。

這種方法將此分頁從一個被動的日誌檢視器，轉變為 SRE 工作流程中一個主動的、智慧化的部分，是提升平台價值的關鍵。

#### AI 事件分析報告 [AI事件分析報告](images/17-彈窗-事件列表-AI事件分析報告.png)

**功能描述**：
- AI驅動的事件分析模態對話框
- 事件詳情顯示：分析事件、嚴重性等級
- 根本原因分析 (RCA) 與置信度評分

**相關 API 端點**：
- `POST /api/v1/events/{id}/ai-analysis` - 觸發AI分析
- `GET /api/v1/ai/analysis-reports/{report_id}` - 獲取分析報告

**UX 改善建議**：
1. **置信度可視化**：使用進度條或色彩編碼顯示分析結果的置信度
2. **互動式分析**：支援用戶對分析結果提供反饋，改善 AI 準確性
3. **多語言支援**：支援分析報告的多語言顯示
4. **相似案例**：顯示歷史上相似事件的處理方案和結果
5. **建議操作**：基於分析結果提供具體的操作建議和優先順序
6. **報告導出**：支援將分析報告導出為 PDF 或分享連結

**Jules 的分析與建議**：

我已審閱此 AI 分析報告的設計。這是展示平台智慧化能力的核心功能，其成敗關鍵在於兩點：**1) 將原始數據轉化為可行動的洞察**，以及 **2) 透過透明度與可驗證性來建立使用者的信任**。現有的分析已經完美地捕捉了這兩點，我將其設計細節確認並固化如下。

**後端架構與 API 設計**：

1.  **非同步分析流程 (Asynchronous Analysis Flow)**:
    *   **第一步：觸發分析**: 使用者點擊「AI 分析」按鈕，呼叫 `POST /api/v1/events/{id}/ai-analysis`。此端點應立即回傳 `202 Accepted` 及一個 `report_id`，並在背景啟動一個非同步的分析任務。此設計確保了即使分析耗時較長，使用者介面也不會被凍結。
        ```json
        // POST /api/v1/events/{id}/ai-analysis -> 202 Accepted
        {
          "report_id": "rep_a1b2c3",
          "status": "PENDING"
        }
        ```
    *   **第二步：獲取報告**: 前端使用 `report_id` 來輪詢 `GET /api/v1/ai/analysis-reports/{report_id}`。此端點將回傳報告狀態 (`PENDING`, `RUNNING`, `SUCCESS`, `FAILED`)。當狀態為 `SUCCESS` 時，則一併回傳完整的報告內容。（或可使用 WebSocket 將結果主動推送至前端）。

2.  **`GET /api/v1/ai/analysis-reports/{report_id}` - 結構化 Payload**:
    報告的 Payload 必須是高度結構化的，以驅動 UI 的呈現。其中的 `evidence` 和 `recommended_actions` 是建立信任和實現可操作性的關鍵。

    ```json
    {
      "report_id": "rep_a1b2c3",
      "status": "SUCCESS",
      "generated_at": "2025-09-18T11:20:00Z",
      "event_summary": "API latency over 500ms",
      "root_cause_analysis": {
        "text": "根本原因很可能在於 'user-authentication' 服務中的內存洩漏，導致下游服務的連鎖故障。",
        "confidence_score": 0.85,
        "evidence": [
          {
            "type": "METRIC",
            "description": "指標 'user-authentication_memory_usage' 呈現異常增長。",
            "link": {
              "name": "查看指標圖表",
              "url": "/dashboards/d/xyz?var-service=user-authentication"
            }
          }
        ]
      },
      "impact_assessment": {
        "text": "對用戶登錄和註冊功能造成嚴重影響。用戶數據庫可能存在數據不一致的風險。",
        "affected_resources": [
          { "id": "res_abc", "name": "user-authentication-svc" },
          { "id": "res_def", "name": "login-gateway" }
        ]
      },
      "recommended_actions": [
        {
          "title": "立即重啟 'user-authentication' 服務",
          "action_type": "AUTOMATION",
          "risk": "HIGH",
          "action_data": {
            "script_id": "scr_restart_service",
            "parameters": { "service_name": "user-authentication" }
          }
        },
        {
          "title": "檢查 db-prod-01 日誌",
          "action_type": "LINK",
          "risk": "LOW",
          "action_data": { "url": "/logs?query={resource='db-prod-01'}" }
        }
      ]
    }
    ```

3.  **使用者反饋迴路 API (User Feedback Loop API)**:
    *   `POST /api/v1/ai/analysis-reports/{report_id}/feedback`: 此 API 對於透過 RLHF (Reinforcement Learning from Human Feedback) 來優化 AI 模型至關重要。
    *   **Request Body**:
        ```json
        {
          "is_helpful": true, // or false
          "correct_action_key": "rollback_deployment", // 可選：哪個操作是正確的？
          "comment": "根本原因正確，但重啟不是最佳方案。" // 可選
        }
        ```

**UX/UI 強化建議**：

1.  **透明度與可信度 (Transparency & Trust)**:
    *   **展示證據 (Show, Don't Just Tell)**: RCA 和影響評估區塊不應只有文字。它們**必須**附帶可點擊的**證據連結**（由 API Payload 中的 `evidence` 驅動）。這使得 SRE 能夠輕易驗證 AI 的結論，從而建立對系統的信任。
    *   **視覺化置信度**: 置信度分數（如 85%）應該用進度條或儀表盤等視覺化元件來呈現，而非純文字。

2.  **可操作的建議 (Actionable Recommendations)**:
    *   **數據驅動的按鈕**: 每個建議操作旁邊的按鈕必須完全由 `recommended_actions` 陣列驅動。`AUTOMATION` 類型的按鈕觸發腳本執行流程，而 `LINK` 類型則引導使用者跳轉。
    *   **風險標示**: 每個操作都應被視覺化地標記其 `risk` 等級（例如，高風險操作如「重啟」應使用紅色且更醒目的按鈕樣式），以幫助使用者做出明智的決策。

3.  **反饋機制 (Feedback Mechanism)**:
    *   在報告的底部，必須有一個簡單明瞭的反饋機制（例如，「這個分析有幫助嗎？ 👍 / 👎」）。捕獲這些反饋對於 AI 模型的長期改進至關重要。

總之，此功能的設計應將 AI 從一個「黑盒子」轉變為一個透明、可驗證、可操作的 SRE 助手。

#### 建立靜音 [建立靜音](images/18-彈窗-事件規則-建立靜音.png)

**功能描述**：
- 從具體活躍事件快速建立臨時靜音規則的彈窗
- 顯示要靜音的事件基本資訊供確認
- 提供預設的靜音時長選項

**相關 API 端點**：
- `POST /api/v1/silence-rules` - 建立新的靜音規則

**UX 改善建議**：
1. **快速選項**：提供常用靜音時長的快速選擇按鈕（15分鐘、1小時、4小時、24小時）
2. **影響預覽**：顯示靜音規則將影響的其他相關事件數量
3. **範圍驗證**：即時驗證靜音規則的匹配範圍，避免過度靜音
4. **定時提醒**：支援設定靜音到期前的提醒通知
5. **原因記錄**：要求或建議填寫靜音原因，便於後續追蹤和分析

**Jules 的分析與建議**：

我已審閱此設計。此對話框是 SRE 為應對告警或計劃性維護而暫時降噪的關鍵、高頻工作流程。其設計必須快速、清晰且安全。現有的分析準確地指出了其核心架構：作為 Grafana API 的一個智慧代理。我將此方向確認並細化如下。

**後端架構與 API 設計 (Grafana 代理模式)**

1.  **核心邏輯：代理至 Grafana (Proxy to Grafana)**:
    根據 `docs/architecture.md`，本平台作為「統一管理平面」。因此，當使用者點擊「建立靜音」時，本平台後端的主要職責是**呼叫 Grafana 的 `POST /api/v1/silences` 端點**。平台自身資料庫僅儲存此操作的審計記錄，將內部的 `event_id`、`user_id` 與 Grafana 回傳的 `silence_id` 關聯起來。

2.  **`POST /api/v1/silence-rules` - API 設計**:
    此 API 用於建立一個**一次性**的靜音規則。
    *   **Request Body**:
        ```json
        {
          "event_id": "evt_2a7d3e9f-8b4c-4f1a-9e2d-6c1f8a7b3e9f",
          "duration": "1h", // 例如 "15m", "4h", "24h"
          "comment": "正在手動清理磁碟空間，暫時靜音。" // 必須提供
        }
        ```
    *   **後端處理邏輯**:
        1.  接收請求，驗證 `comment` 不得為空。
        2.  從資料庫/快取中獲取 `event_id` 的完整詳情。
        3.  **智慧地從事件資料中提取關鍵標籤** (如 `alertname`, `instance`, `job`, `severity`)，這些標籤將構成 Grafana 靜音規則的 `matchers`。
        4.  計算 `startsAt` (當前時間) 和 `endsAt` (當前時間 + duration) 的 ISO 8601 格式時間戳。
        5.  建構呼叫 Grafana API (`POST /api/v1/silences`) 的 Payload，其中 `comment` 欄位來自請求。
        6.  呼叫 Grafana API，並處理可能的錯誤。
        7.  儲存審計記錄並向前端回傳成功訊息。

3.  **影響範圍預覽 API (`POST /api/v1/silence-rules/preview`)**:
    為了實現「影響預覽」這個重要的 UX 功能，需要一個「試運行」API。
    *   **Request Body**: 包含從事件中提取出的建議 `matchers`。
    *   **後端邏輯**: 後端將這些 `matchers` 轉發給 Prometheus/VictoriaMetrics 的 `/api/v1/series` API，以獲取當前正在觸發告警且符合條件的時間序列數量。
    *   **Response**: `{ "affected_series_count": 5 }`

**UX/UI 強化建議**：

1.  **強制要求「原因」並提供輸入框 (Mandatory Reason Field)**: 靜音告警是一個重要操作，必須追蹤其原因。目前的 UI 設計缺少此欄位。應在「靜音設定」區塊中**新增一個必填的「原因」文字輸入框**。這強制了問責制，並為團隊成員和未來審計提供了關鍵上下文。

2.  **明確化「靜音範圍」 (Clarify Silence Scope)**: 此彈窗**必須**明確地向使用者展示將用於靜音的標籤。在「事件資訊」區塊下方，新增一個名為「**靜音匹配條件**」的區塊，顯示從事件中提取的確切鍵值對 (例如：`alertname = DiskSpaceLow`, `instance = srv-web-prod-02`)。這種透明度對於防止使用者意外地靜音過多告警至關重要。

3.  **即時影響預覽 (Live Impact Preview)**: 當彈窗載入時，前端應自動呼叫 `POST /api/v1/silence-rules/preview` API。結果應清晰地顯示，例如：「**此規則將影響目前 5 條活躍告警。**」。這讓使用者在提交前能立即了解其操作的影響。

4.  **提供進階選項 (Provide Advanced Options)**: 在「靜音匹配條件」區塊旁，新增一個「**編輯匹配條件**」的連結或按鈕。點擊後允許高階使用者修改 `matchers`（例如，透過移除 `instance` 匹配條件，將靜音範圍從單一實例擴大到整個 `job`），以應對更複雜的場景。

#### 編輯事件規則 - 基本資訊 [編輯事件規則1-基本資訊](images/19-彈窗-事件規則-編輯事件規則1-基本資訊.png)

**功能描述**：
- 事件規則編輯精靈的第一步
- 定義規則名稱、描述及監控資源標籤
- 提供快速套用範本功能

**相關 API 端點**：
- `GET /api/v1/event-rule-templates` - 獲取可用的快速範本列表

**UX 改善建議**：
1. **範本預覽**：提供範本的詳細說明和預覽效果
2. **智能推薦**：基於資源類型和業務場景推薦適合的範本
3. **自定義範本**：支援將常用配置儲存為自定義範本
4. **標籤建議**：根據選擇的資源自動建議相關標籤
5. **驗證檢查**：即時驗證資源標籤的有效性和存在性

**Jules 的分析與建議**：

我已審閱此設計。此精靈是建立告警規則的主要介面，其成功與否取決於能否將 Grafana PromQL/MetricQL 的複雜性抽象化，提供一個引導式、安全且直觀的體驗。第一步「基本資訊」對於定義規則的身份，以及最重要的「監控範圍」至關重要。現有的分析已為此提供了正確的藍圖，我將其設計確認如下。

**後端架構與 API 設計 (Grafana 代理模式)**

1.  **核心邏輯 - Grafana 代理**: 必須明確，此精靈整體是一個友善的前端，用以建構一個複雜的 JSON 物件，並最終發送到 **Grafana Alerting API**。此處的「監控資源標籤」區塊，就是建構 Grafana 告警規則中標籤選擇器的 UI。

2.  **範本 API (`GET /api/v1/event-rule-templates`)**:
    此 API 是「快速套用範本」功能的關鍵。其回應應為一個範本物件陣列，每個物件包含**所有精靈步驟**的預設資料。

    *   **Response Payload 範例**:
        ```json
        [
          {
            "id": "tpl_cpu_high",
            "name": "CPU 使用率過高",
            "description": "當 CPU 使用率持續超過 90% 時觸發。",
            "prefilled_data": {
              "rule_name": "CPU 使用率過高 on {{ $labels.instance }}",
              "rule_description": "監控 {{ $labels.instance }} 的 CPU 使用率。",
              "scope_tags": [{ "key": "job", "value": "node_exporter" }],
              "trigger_conditions": { /* ...預設的觸發條件資料... */ },
              "event_content": { /* ...預設的事件內容模板... */ },
              "automation_tasks": [ /* ...預設的自動化任務設定... */ ]
            }
          }
        ]
        ```

3.  **標籤選擇器 APIs (Tag Selector APIs)**:
    互動式的「監控資源標籤」UI 需要兩個 API 來提供智慧提示並防止輸入錯誤。
    *   `GET /api/v1/tags/keys`: 獲取監控系統中所有可用的標籤**鍵** (如 `["env", "app", "dc", "job", "instance"]`)。後端透過 Prometheus/VictoriaMetrics 的元數據 API (`/api/v1/labels`) 取得此列表。
    *   `GET /api/v1/tags/values?key=env`: 獲取指定標籤鍵的所有已知**值**及其使用次數。後端透過 `/api/v1/label/env/values` 取得。
        ```json
        // GET /api/v1/tags/values?key=env
        [
          { "value": "production", "usage_count": 45 },
          { "value": "staging", "usage_count": 20 }
        ]
        ```

4.  **前端狀態管理 (Frontend State Management)**:
    當使用者點擊「下一步：觸發設定」時，**不應**有後端 API 呼叫。此表單的資料 (`rule_name`, `description`, `scope_tags`) 應儲存在前端的狀態管理器中，並傳遞給後續步驟。最終完整的規則物件只在最後一步完成時，才組裝並發送到後端。

**UX/UI 強化建議**：

1.  **即時範圍預覽 (Live Scope Preview)**: 這是一個高價值功能。當使用者在「監控資源標籤」區塊新增或移除標籤時，前端應使用 debounce 機制呼叫一個新的 `POST /api/v1/event-rules/scope-preview` 端點。此 API 接收目前的 `matchers` 並回傳將被監控的資源數量。UI 上應清晰地顯示：「**目前的標籤組合將監控 12 個資源。**」，這能讓使用者對其設定的範圍有即時的信心。

2.  **範本預覽 (Template Preview)**: 當使用者滑鼠懸停在「快速套用範本」中的某個範本上時，應出現一個工具提示或小型彈出視窗，總結該範本將在所有四個步驟中配置的內容，幫助使用者在點擊前做出明智的選擇。

3.  **標籤輸入引導 (Guided Tag Input)**: 新增標籤的 UI 很不錯。應進一步增強，防止使用者重複新增相同的標籤鍵。一旦如 `env` 的鍵被加入，它就應該從可用鍵的下拉列表中移除，以避免衝突。

透過這些 API 和 UX 設計，我們可以將複雜的告警範圍定義過程，轉化為一個對使用者友好且不易出錯的引導式體驗。

#### 編輯事件規則 - 觸發條件 [編輯事件規則2-觸發條件](images/20-彈窗-事件規則-編輯事件規則2-觸發條件.png)

**功能描述**：
- 事件規則編輯精靈的第二步
- 定義觸發事件的具體條件
- 支援複雜的邏輯運算式

**相關 API 端點**：
- `GET /api/v1/metrics` - 獲取所有可用的監控指標列表

**UX 改善建議**：
1. **視覺化條件編輯器**：提供拖拽式的條件編輯器，降低配置複雜度
2. **條件模擬**：支援使用歷史數據模擬觸發條件的效果
3. **閾值建議**：基於歷史數據分析，提供智能閾值建議
4. **條件預覽**：即時顯示條件邏輯的自然語言描述
5. **複雜運算式**：支援更複雜的邏輯運算和時間窗口配置

**Jules 的分析與建議**：

我已審閱此設計。這是規則建立精靈中最核心、技術上最複雜的一步。其目標是將強大但極其複雜的 PromQL/MetricQL 查詢，抽象成一個任何 SRE 成員都能理解和操作的視覺化介面。現有的分析已經為此挑戰提供了非常出色的解決方案，我將其核心邏輯與 UX 強化建議確認並細化如下。

**後端架構與 API 設計 (Grafana 代理模式)**

1.  **核心邏輯 - 翻譯為 Grafana 查詢**:
    此 UI 的結構 (`(A AND B) OR (C)`) 完美地對應 Grafana 統一告警模型中的多個查詢和條件。後端的核心職責是將這個 UI 結構**翻譯**成 Grafana 能理解的 API Payload。
    *   每一個「條件群組 (OR)」對應到 Grafana 規則中的一個獨立的 `data` 查詢物件，擁有自己的 `refId` (e.g., 'A', 'B')。
    *   群組內的「AND 條件」會被後端合併成一個單一的查詢表達式。例如，`記憶體使用率 > 80%` 和 `資料庫延遲 > 5s` 會被翻譯成類似 `(mem_usage > 80) and (db_latency > 5)` 的 PromQL。
    *   最終，還需要一個 `Expression` 類型的 `data` 物件，其表達式為 `A || B`，用以組合所有的 OR 條件群組。
    *   每個「條件群組」設定的「事件等級」(INFO/WARNING/CRITICAL)，會被作為 `label` 附加到對應的 Grafana `data` 查詢物件上，這是實現多等級告警的關鍵。

2.  **指標 API (`GET /api/v1/metrics`)**:
    此 API 用於填充指標下拉選單，其回傳的內容必須是結構化的，而不僅僅是名稱。後端儲存 `query_template`，使得查詢邏輯的複雜性對前端完全隱藏，極大降低了前端實作的難度。

    *   **Response Payload 範例**:
        ```json
        [
          {
            "id": "metric_cpu_usage",
            "name": "CPU 使用率 (%)",
            "description": "主機的平均 CPU 使用率。",
            "unit": "%",
            "query_template": "100 - (avg by (instance) (rate(node_cpu_seconds_total{mode=\"idle\"}[5m])) * 100)"
          }
          // ... more metrics
        ]
        ```

3.  **條件模擬 API (`POST /api/v1/event-rules/preview-condition`)**:
    為了實現「條件模擬」這個強大的 UX 功能，需要一個 API 來預覽查詢效果。
    *   **Request Body**: 前端將目前使用者建構的條件，轉換為查詢表達式後發送給後端。
    *   **後端邏輯**: 後端拿著這個 `expression` 去查詢時序資料庫 (Prometheus/VictoriaMetrics)。
    *   **Response**: 回傳繪製圖表所需的時序數據，前端收到後可以在一個小型預覽圖表中，將指標曲線和閾值線一同繪製出來，讓使用者直觀看到在過去 24 小時內，此規則會觸發多少次。

**UX/UI 強化建議**：

1.  **智慧閾值推薦 (Smart Threshold Suggestions)**: 當使用者選擇了一個指標（如「CPU 使用率」）後，系統可以自動呼叫 API 分析該指標在過去一段時間（如一週）的 P95、P99 百分位數，並將這些數值作為建議的 `WARNING` 和 `CRITICAL` 閾值提供給使用者參考。這是從「工具」到「助手」的關鍵一步。

2.  **自然語言預覽 (Natural Language Preview)**: 在頁面底部或側邊，提供一個唯讀的文字區塊，用人類可讀的語言即時總結使用者建立的複雜規則。例如：
    > 「當 (**記憶體使用率** 在 5 分鐘內持續 **> 80%**) 且 (**資料庫複製延遲** 在 5 分鐘內持續 **> 5 秒**) 時，將觸發 **WARNING** 等級的事件；或者當 (**CPU 使用率** 在 5 分鐘內持續 **> 85%**) 時，將觸發 **CRITICAL** 等級的事件。」

    這能極大地降低使用者因邏輯複雜而出錯的機率，是提升易用性的關鍵。

3.  **錯誤與衝突檢查**: 當使用者輸入閾值或選擇指標時，進行即時的語法和邏輯檢查，防止例如閾值單位不匹配等基本錯誤。

透過這種方式，我們將 Grafana 強大的能力，透過一個精心設計的抽象層，安全、有效地提供給了使用者。

#### 編輯事件規則 - 事件內容 [編輯事件規則3-事件內容](images/21-彈窗-事件規則-編輯事件規則3-事件內容.png)

**功能描述**：
- 事件規則編輯精靈的第三步
- 自訂當事件被觸發時的標題和內容
- 支援變數替換和Markdown語法

**相關 API 端點**：
- `GET /api/v1/event-rules/template-variables` - 獲取可用變數列表

**UX 改善建議**：
1. **實時預覽**：提供事件內容的實時預覽，包含變數替換效果
2. **Markdown 編輯器**：內建 Markdown 編輯器，支援語法高亮和即時預覽
3. **變數助手**：提供變數插入助手，支援搜尋和分類瀏覽
4. **範本庫**：內建常用的事件內容範本
5. **多語言支援**：支援不同語言的事件內容範本

**Jules 的分析與建議**：

我已審閱此設計。此步驟定義了當告警觸發時，On-Call 工程師將會看到「什麼內容」。一個清晰、資訊豐富、包含上下文的事件內容，對於快速響應至關重要。現有的分析已準確地指出了實現此目標的核心：打造一個既易於使用，又能直接映射到 Grafana 引擎的強大模板化體驗。我將其設計確認如下。

**後端架構與 API 設計 (Grafana 代理模式)**

1.  **核心邏輯 - 映射至 Grafana Annotations**:
    此 UI 直接設定 Grafana 告警規則的 `annotations`。
    *   **事件標題樣板**: 此欄位的內容將填入 Grafana 規則的 `summary` annotation。
    *   **事件內容樣板**: 此欄位的內容將填入 `description` annotation。
    *   **變數格式**: UI 中使用的 `{{variable}}` 語法，後端在發送給 Grafana 前，會將其翻譯成 Grafana 相容的 Go 模板語法 (例如 `{{ .Labels.instance }}`)。

2.  **變數 API (`GET /api/v1/event-rules/template-variables`)**:
    此 API 為 UI 的「可用變數」區塊和「即時預覽」功能提供數據。其回應必須是結構化的，包含變數名稱、描述和一個用於預覽的範例值。

    *   **Response Payload 範例**:
        ```json
        [
          {
            "name": "{{resource.name}}",
            "description": "觸發事件的資源名稱。",
            "example_value": "db-mysql-prod-01"
          },
          {
            "name": "{{metric.value}}",
            "description": "觸發事件時的指標數值。",
            "example_value": "92.5"
          },
          {
            "name": "{{threshold}}",
            "description": "規則中設定的閾值。",
            "example_value": "90"
          }
        ]
        ```

3.  **前端狀態管理**:
    與前幾個步驟相同，此處輸入的所有資料 (`title_template`, `content_template`) 都會被加入到正在前端狀態中建構的規則物件裡。進入下一步時無需呼叫 API。

**UX/UI 強化建議**：

1.  **即時預覽 (Live Preview)**: 這是**不可或缺的必備功能**。頁面應包含一個「預覽」面板，隨著使用者在模板中輸入而即時更新。此面板應使用 API 回傳的 `example_value` 來渲染出最終告警的樣貌，給予使用者最直接的反饋，確保所見即所得。
    *   **預覽範例**:
        > **標題**: `db-mysql-prod-01 - CPU 使用率 (%) 異常`
        > **內容**: `db-mysql-prod-01 的 CPU 使用率 (%) 已持續 5 分鐘超過閾值 90。目前數值為 92.5。請立即關注！`

2.  **分級事件內容 (Per-Severity Content)**: (進階功能) 目前的 UI 為整個規則定義了一套標題/內容。一個重要的功能增強是，允許使用者為上一步中定義的**不同事件等級（WARNING, CRITICAL）設定不同的模板**。
    *   UI 可在「事件內容」區塊中使用頁籤 (`WARNING`, `CRITICAL`) 來切換。
    *   這將帶來更豐富的通知。例如，`CRITICAL` 告警的內容可以自動包含 On-Call 手冊的連結和 `@on-call-lead` 的升級路徑，而 `WARNING` 告警可能只包含儀表板的連結。

3.  **內建 Markdown 編輯器 (Built-in Markdown Editor)**: 「事件內容樣板」的輸入框應為一個所見即所得（WYSIWYG）的 Markdown 編輯器，提供基礎的格式化工具（如粗體、斜體、列表、連結），讓非技術使用者也能輕鬆建立豐富且易讀的告警內容。

總之，一個具備即時預覽和豐富變數支援的模板化系統，是確保告警通知品質的關鍵。

#### 編輯事件規則 - 自動化 [編輯事件規則4-自動化](images/22-彈窗-事件規則-編輯事件規則4-自動化.png)

**功能描述**：
- 事件規則編輯精靈的第四步
- 設定事件觸發時的自動化響應動作
- 支援腳本參數配置和測試功能

**相關 API 端點**：
- `GET /api/v1/scripts?compatible_with=event_rules` - 獲取適用腳本列表
- `POST /api/v1/event-rules` - 建立或更新完整的事件規則

**UX 改善建議**：
1. **腳本測試**：提供腳本的測試執行功能，驗證參數和執行結果
2. **參數映射**：智能映射事件屬性到腳本參數
3. **執行條件**：支援設定腳本的執行條件和優先級
4. **結果處理**：配置腳本執行結果的處理方式（更新事件狀態、發送通知等）
5. **依賴管理**：支援腳本間的依賴關係和執行順序

**Jules 的分析與建議**：

我已審閱此設計。這是將平台從一個被動的監控工具，提升為一個具備主動修復能力的「自愈」系統的關鍵一步。其核心是建立事件規則與自動化腳本之間清晰、可靠且安全的綁定。

**後端架構與 API 設計**：

1.  **最終規則 Payload (`POST /api/v1/event-rules`)**:
    這是精靈的最後一步。當使用者點擊「完成」時，前端應將所有四個步驟的資料組裝成一個完整的規則物件。其中的 `automation` 部分應具備靈活的結構，以支援靜態和動態參數。

    *   **Automation 物件結構範例**:
        ```json
        // 包含在最終事件規則物件中的 automation 欄位
        "automation": {
          "enabled": true,
          "script_id": "scr_auto_scaling_for_web_servers",
          "parameters": [
            {
              "name": "instance_count",
              "value_type": "STATIC", 
              "value": "3"
            },
            {
              "name": "target_resource",
              "value_type": "DYNAMIC_FROM_EVENT",
              "value": "{{resource.name}}"
            }
          ]
        }
        ```

2.  **腳本列表 API (`GET /api/v1/scripts`)**:
    此 API 用於填充「選擇腳本」下拉選單，其回傳的內容**必須**包含每個腳本的參數定義，以便 UI 動態生成參數輸入欄位。

    *   **Response Payload 範例**:
        ```json
        [
          {
            "id": "scr_auto_scaling_for_web_servers",
            "name": "Auto-scaling for Web Servers",
            "description": "動態擴展 Web 伺服器實例數量。",
            "parameters": [
              {
                "name": "instance_count",
                "type": "INTEGER",
                "required": true,
                "description": "期望的實例總數。"
              },
              {
                "name": "target_resource_group",
                "type": "STRING",
                "required": true,
                "description": "要擴展的資源群組名稱。"
              }
            ]
          }
        ]
        ```

3.  **後端觸發邏輯**:
    當事件規則被觸發時，事件處理服務會檢查規則中是否包含已啟用的 `automation` 設定。如果有，它將：
    a. 解析 `parameters` 陣列，將 `DYNAMIC_FROM_EVENT` 類型的參數值（如 `{{resource.name}}`）替換為真實的事件內容。
    b. 向**自動化執行服務**發送一個新的執行任務請求，包含 `script_id` 和解析後的完整參數。
    c. 該次執行將被記錄到 `execution_logs` 表，並包含觸發它的 `event_id`，以實現完整的可追溯性。

**UX/UI 強化建議**：

1.  **智慧參數映射 (Intelligent Parameter Mapping)**: 這是此介面的**核心體驗**。當使用者選擇一個腳本後，UI 應根據腳本的 `parameters` 定義，為每個參數動態生成一個輸入元件。
    *   **提供映射選項**: 每個參數輸入元件旁，都應有一個切換開關或下拉選單，允許使用者在「**靜態值**」（手動輸入）和「**從事件中獲取**」之間選擇。
    *   **動態變數選擇**: 當選擇「從事件中獲取」時，應提供一個包含所有可用事件變數（如 `{{resource.name}}`, `{{metric.value}}`）的下拉選單，供使用者選擇。
    *   **智慧推薦**: 如果腳本參數的名稱（如 `target_resource`）與事件變數的名稱（如 `resource.name`）相似，系統應自動推薦此映射，以減少使用者的配置負擔。

2.  **增加確認步驟 (Final Confirmation Step)**: 在點擊「完成」按鈕之前，強烈建議增加一個唯讀的「**確認設定**」步驟。此頁面將清晰地匯總前四步的所有配置，讓使用者在儲存前有最後一次機會審查整個規則，特別是將要執行的自動化動作及其參數，這是防止錯誤配置的關鍵安全措施。

3.  **權限與安全 (Permissions & Security)**: `GET /api/v1/scripts` API 回傳的腳本列表**必須**基於當前使用者的權限進行過濾。並非所有使用者都有權限將所有腳本（特別是高風險腳本）設定為自動執行。

#### 編輯靜音規則 - 基本資訊 [編輯靜音規則1-基本資訊](images/23-彈窗-靜音規則-編輯靜音規則1-基本資訊.png)

**功能描述**：
- 靜音規則編輯精靈的第一步
- 定義規則名稱和描述
- 提供快速套用範本功能

**相關 API 端點**：
- `GET /api/v1/silence-rule-templates` - 獲取可用的快速範本列表

**UX 改善建議**：
1. **常用範本**：提供常用靜音場景的範本（維護窗口、部署期間、營業時間外）
2. **範本自定義**：支援將目前配置儲存為範本，供未來重複使用
3. **分享機制**：支援範本在團隊間的分享和協作
4. **範本驗證**：在應用範本前預覽其影響範圍
5. **權限控制**：基於角色和團隊控制範本的使用權限

**Jules 的分析與建議**：

我已審閱此設計。此精靈是用於建立**可重複使用的、週期性的靜音規則**，這是本平台的核心功能之一，旨在解決原生 Grafana 功能的不足。此第一步的重點在於定義規則的業務目的，並透過範本加速常見場景的設定。

**後端架構與 API 設計**：

1.  **核心邏輯 - 平台管理的排程作業**:
    週期性靜音規則是本平台獨有的概念。後端**必須**在自身資料庫中儲存完整的規則定義（名稱、描述、CRON 排程、匹配範圍等）。一個獨立的**排程器服務**會：
    a. 定期檢查所有已啟用的週期性靜音規則。
    b. 當偵測到某個規則進入其生效時間時，動態地**透過 Grafana API 建立一個標準的一次性靜音 (Silence)**。
    c. 在規則的失效時間到達時，再次**透過 Grafana API 刪除**該次性靜音。

2.  **範本 API (`GET /api/v1/silence-rule-templates`)**:
    「快速套用範本」功能是提升效率的關鍵。此 API 的回應應包含能預先填寫精靈所有步驟的資料。

    *   **Response Payload 範例**:
        ```json
        [
          {
            "id": "tpl_weekend_maintenance",
            "name": "週末維護窗口",
            "prefilled_data": {
              "rule_name": "週末資料庫維護窗口",
              "description": "每週六凌晨 2-4 點的資料庫例行維護，期間靜音相關告警。",
              "schedule": {
                "type": "RECURRING",
                "cron": "0 2 * * 6", // At 02:00 on Saturday
                "duration": "2h"
              },
              "scope": {
                "matchers": [
                  { "key": "service", "value": "user-database", "isRegex": false }
                ]
              }
            }
          }
        ]
        ```

3.  **前端狀態管理**:
    與事件規則精靈一樣，點擊「下一步」時**不應**呼叫 API。此步驟的資料 (`rule_name`, `description`) 應儲存在客戶端狀態管理器中，待精靈最後一步完成時，才將完整的規則物件組裝並發送到後端。

**UX/UI 強化建議**：

1.  **範本優先的工作流程 (Template-First Workflow)**:
    此介面設計已經很好地突顯了範本。可以進一步強化，例如在視覺上將範本區塊置於更核心的位置，引導使用者將其作為首選的、最快的操作路徑。

2.  **允許儲存自訂範本 (Custom Templates)**:
    在精靈的最後確認步驟中，提供一個「**另存為範本**」的核取方塊或按鈕。這能讓團隊將自己常用的維護操作（如「每月結算批次作業」）儲存起來，極大提升未來操作的效率和一致性。

3.  **引導式文字 (Guiding Placeholder Text)**:
    「規則名稱」和「描述」對於未來管理和審計至關重要。輸入框的預設提示文字應引導使用者撰寫清晰、有意義的內容，例如，在「描述」中提示：「請簡述此靜音規則的目的、範圍和時間，以便團隊其他成員理解。」

#### 編輯靜音規則 - 設定排程 [編輯靜音規則2-設定排程](images/24-彈窗-靜音規則-編輯靜音規則2-設定排程.png)

**功能描述**：
- 靜音規則編輯精靈的第二步
- 定義靜音規則的生效時間
- 支援單次和週期性靜音

**相關 API 端點**：
- 無特定API，設定值將序列化儲存

**UX 改善建議**：
1. **視覺化時間選擇器**：提供日曆和時間軸交互式選擇器
2. **預設時間段**：內建常用時間段（工作時間、非工作時間、週末）
3. **時區支援**：支援不同時區的時間設定和轉換
4. **排程衝突檢查**：自動檢查與現有靜音規則的時間衝突
5. **重覆預覽**：顯示在選定時間內的靜音覆蓋情況

**Jules 的分析與建議**：

我已審閱此設計。這是週期性靜音規則功能的核心，其挑戰在於提供一個簡單易懂的 UI，同時能在後端轉譯為精確的機器可讀排程 (CRON 表達式)。

**後端架構與 API 設計**：

1.  **核心邏輯 - UI 至 CRON 的翻譯**:
    此步驟的設定將被保存在前端狀態中，直到精靈完成的最後一步才統一提交。後端在收到最終的規則物件時，**必須**包含一個強大的翻譯邏輯，將 UI 中的語意化選項轉換為標準的 CRON 表達式。

    *   **UI 選項**: `重複模式: 每月`, `執行日期: 每月最後一天`, `靜音時段: 22:00`, `持續時間: 8小時`
        **後端翻譯** -> `cron: "0 22 L * *"` 且持續時長為 `8h`。
    *   **UI 選項**: `重複模式: 每週`, `執行日期: 星期一, 星期三`, `靜音時段: 00:00`, `持續時間: 1h`
        **後端翻譯** -> `cron: "0 0 * * 1,3"` 且持續時長為 `1h`。

    儲存於平台資料庫中的規則，應同時包含語意化選項和最終生成的 CRON 字串，以供排程器服務使用。

2.  **前端狀態的 Payload 結構**:
    在前端狀態管理器中構建的 `schedule` 物件應具備如下結構：

    ```json
    "schedule": {
      "type": "RECURRING", // 或 "ONE_TIME"
      "recurrence": {
        "mode": "MONTHLY", // "DAILY", "WEEKLY", "MONTHLY"
        "day_of_month": "LAST_DAY", // 或 1-31
        "day_of_week": null // 或 ["MON", "WED"]
      },
      "time_period": {
        "start_time": "22:00:00",
        "duration": "8h"
      },
      "validity": {
        "type": "PERMANENT", // "UNTIL_DATE", "EXECUTE_COUNT"
        "end_date": null,
        "count": null
      },
      "timezone": "Asia/Taipei" // 必須明確指定時區
    }
    ```

**UX/UI 強化建議**：

1.  **自然語言預覽 (Natural Language Preview)**:
    這是此介面**不可或缺**的功能。頁面中應有一個唯讀的文字區塊，隨著使用者變更選項而即時更新，用人類可讀的語言總結其設定。
    *   **預覽範例**: 「此規則將於**每月最後一天**的 **22:00** 開始生效，並持續 **8 小時**。此排程將**永久有效**。」
    *   **核心價值**: 提供即時、清晰的設定反饋，極大地降低使用者因誤解而配置錯誤的風險。

2.  **明確的時區處理 (Explicit Time Zone Handling)**:
    時區是排程功能中最常見的錯誤來源。
    *   **顯示當前時區**: UI **必須**在時間設定旁清晰地標示出當前所使用的時區（例如：「所有時間均以 **Asia/Taipei** 時區為準」）。
    *   **允許使用者選擇**: 理想情況下，應提供一個下拉選單讓使用者選擇他們期望的時區，並將該值 (`schedule.timezone`) 持久化。後續所有時間計算應由後端基於此時區進行。

3.  **排程衝突視覺化 (Schedule Conflict Visualization)**:
    在儲存前，系統應能檢查並提示潛在的排程衝突。
    *   **API 建議**: `POST /api/v1/silence-rules/check-conflict`，此 API 接收一個排程草稿，並回傳與之重疊的現有規則列表。
    *   **UI 提示**: 在精靈的最後確認步驟中，顯示一個非阻斷式的警告：「**注意：此排程與『週末維護』規則存在部分時間重疊。**」

4.  **提供進階 CRON 輸入模式 (Advanced CRON Input)**:
    對於高階使用者，應提供一個切換開關，允許他們直接輸入或編輯標準的 CRON 字串。UI 應能雙向同步：簡易模式的選項變更應反映在 CRON 字串上，反之亦然。這能同時滿足不同經驗水平使用者的需求。

#### 編輯靜音規則 - 設定範圍 [編輯靜音規則3-設定範圍](images/25-彈窗-靜音規則-編輯靜音規則3-設定範圍.png)

**功能描述**：
- 靜音規則編輯精靈的第三步
- 定義靜音規則影響的範圍
- 支援複雜的匹配邏輯

**相關 API 端點**：
- `GET /api/v1/resources/groups` - 獲取資源群組列表
- `GET /api/v1/tags/keys` - 獲取所有可用的標籤鍵
- `GET /api/v1/tags/values?key={key}` - 獲取指定標籤鍵的可用值
- `POST /api/v1/silence-rules` - 提交完整的靜音規則以供建立

**UX 改善建議**：
1. **智能匹配**：支援模糊匹配、正則表達式和萬用字元
2. **範圍預覽**：即時顯示匹配條件將影響的資源數量
3. **分組管理**：支援多個匹配組和邏輯關係（AND/OR）
4. **排除模式**：支援正向和反向匹配的組合
5. **歷史範圍**：基於歷史使用的智能建議和快捷設定

**Jules 的分析與建議**：

我已審閱此設計。這是靜音規則建立的最後一步，也是最關鍵的一步。錯誤的範圍設定可能導致錯過關鍵告警，或意外地將整個生產環境靜音。因此，此介面的核心目標必須是**清晰度**與**可預測性**。

**後端架構與 API 設計**：

1.  **核心邏輯 - 翻譯為 Grafana Matchers**:
    此 UI 收集的「靜音條件」最終會被翻譯成 Grafana Silence API 所需的 `matchers` 陣列。
    *   **資源群組**: 這是平台的一個抽象概念。當使用者選擇一個資源群組（如 `monitoring`）時，後端應將其翻譯為一個標準的標籤匹配，例如 `{ "name": "resource_group", "value": "monitoring", "isRegex": false }`。
    *   **資源標籤**: 這直接對應到一個 matcher。UI 中顯示的 `資源標籤 = staging`，將被翻譯為 `{ "name": "env", "value": "staging", "isRegex": false }`。（注意：UI 上的「資源標籤」應改為更精確的標籤鍵，如 `env`）。

2.  **最終規則 Payload (`POST /api/v1/silence-rules`)**:
    當使用者點擊「儲存規則」時，前端會組裝來自所有步驟的資料。`scope` 和 `options` 部分的結構應如下所示：
    ```json
    // 包含在最終靜音規則物件中的欄位
    "scope": {
      "matchers": [
        { "name": "resource_group", "value": "monitoring", "isRegex": false },
        { "name": "env", "value": "staging", "isRegex": false } 
      ]
    },
    "options": {
        "start_immediately": true,
        "send_notification_on_start_end": false
    }
    ```
    後端接收到此物件後，將其儲存至平台資料庫，並由排程器服務根據排程來管理 Grafana 中的實際靜音。

3.  **支援性 APIs**:
    *   `GET /api/v1/resource-groups`: 獲取資源群組列表以填充下拉選單。
    *   `GET /api/v1/tags/keys`: 獲取所有可用的標籤**鍵**以填充下拉選單。
    *   `GET /api/v1/tags/values?key=...`: 獲取指定標籤鍵的所有已知**值**以提供自動完成建議。
    *   `POST /api/v1/silence-rules/preview`: **(關鍵 API)** 此 API 接收一組 `matchers`，並回傳它們當前會影響的活躍告警數量，以實現「即時影響預覽」。

**UX/UI 強化建議**：

1.  **即時影響預覽 (Live Impact Preview)**:
    這是此介面**最重要**的功能，可以極大提升使用者的信心並防止錯誤。
    *   **實現方式**: 當使用者新增、移除或編輯任何一個條件時，UI 應使用 debounce 機制呼叫 `/api/v1/silence-rules/preview` API。
    *   **UI 反饋**: 頁面中應有一個清晰的文字區域，即時反饋結果，例如：「**此範圍將影響 15 個資源上的 23 條活躍告警。**」

2.  **提供完整的匹配運算子 (Operator Flexibility)**:
    目前的 UI 只顯示了 `=` 運算子。為了發揮 Grafana 的全部能力，**必須**支援其完整的運算子集：`!=` (不等於), `=~` (正則表達式匹配), 和 `!~` (正則表達式不匹配)。這對於建立靈活、精確的靜音規則至關重要。

3.  **通知選項的清晰化**:
    「靜音開始/結束時發送通知」是一個很好的功能。其標籤文字應更具體，以管理使用者預期，例如：「**靜音開始/結束時，向我的預設管道發送通知**」。

### 告警規則 [事件規則](images/11-頁面-事件規則.png)

**功能描述**：
- 事件監控規則配置管理
- 規則列表：啟用狀態、規則名稱、監控對象、資源標籤、觸發條件、通知對象
- 規則啟用/停用開關
- 批次操作和篩選功能

**相關 API 端點**：
- `GET /api/v1/event-rules` - 獲取事件規則列表
- `POST /api/v1/event-rules` - 創建新事件規則
- `PUT /api/v1/event-rules/{id}` - 更新事件規則
- `DELETE /api/v1/event-rules/{id}` - 刪除事件規則
- `PUT /api/v1/event-rules/{id}/toggle` - 切換規則啟用狀態

**UX 改善建議**：
1. **規則預覽**：增加規則效果預覽功能
2. **模板化**：提供常用規則模板和快速配置
3. **依賴關係**：顯示規則之間的依賴關係
4. **測試功能**：增加規則測試和驗證功能
5. **使用統計**：顯示規則觸發頻率和效果統計

**Jules 的分析與建議**：

我已審閱此分析。將此頁面定位為 Grafana Alerting 的「**智慧型抽象層**」是完全正確的架構決策。其核心價值不在於重建告警引擎，而在於提供**遠超原生 Grafana 的易用性和智慧化功能**。以下建議是實現此價值的關鍵。

此頁面的核心價值在於**提供一個比原生 Grafana UI 更簡單、更強大、更符合 SRE 工作流程的規則管理體驗**。它不是要重建告警引擎，而是要成為 Grafana Alerting 的**智慧型抽象層 (Intelligent Abstraction Layer)**。

**後端架構與 API 設計 (Grafana 代理模式)**：
1.  **核心職責：翻譯與代理**：本模組的後端服務，其本質是一個**請求翻譯與代理器**。它接收來自前端的、簡化過的規則定義，將其**翻譯**成 Grafana API 所要求的複雜 JSON 格式，然後透過 API 呼叫 Grafana 來完成規則的增、刪、改、查。
2.  **API 端點即 Grafana 代理**：
    *   `GET /api/v1/event-rules`：此 API 應呼叫 Grafana 的 `GET /api/ruler/grafana/api/v1/rules`，獲取規則列表後，將其**反向翻譯**成前端所需的簡化格式。
    *   `POST /api/v1/event-rules`：接收前端的簡易規則模型，轉換後呼叫 Grafana 的 `POST /api/ruler/grafana/api/v1/rules/{Namespace}`。
    *   `PUT /api/v1/event-rules/{id}/toggle`：本質上是讀取完整的 Grafana 規則，修改其 `enabled` 欄位，然後再寫回去。
3.  **資料庫角色：映射與快取**：本地 PostgreSQL 資料庫不應儲存完整的規則定義（SSOT 在 Grafana），而應主要用於儲存**平台內部 ID 與 Grafana Rule UID 的映射關係**，並可選擇性地快取部分元數據以提高列表頁的載入效能。
4.  **一致性校驗**：必須設計一個背景排程作業，定期（如每小時）從 Grafana 全量同步規則，與本地映射表進行比對，以偵測並修復任何在 Grafana 中手動修改而導致的狀態不一致。

**UX/UI 強化建議 (超越原生 Grafana)**：
1.  **視覺化規則建構器**：這是最重要的價值所在。提供一個**引導式的、視覺化的規則建構器**，讓使用者透過下拉選單選擇指標、運算子、聚合函數，並輸入閾值。系統在背景自動生成複雜的 PromQL/MetricQL 查詢表達式。
2.  **規則「試運行」與影響評估 (Dry Run)**：在儲存規則前，提供「**試運行**」功能。後端接收到規則定義後，拿它去查詢過去一段時間（如 24 小時）的時序數據，並在前端圖表上繪製出指標曲線、閾值線，以及所有**模擬觸發**的時間點。這能讓使用者在規則上線前，直觀地評估其靈敏度與準確性。
3.  **專家知識範本化**：內建一個由資深 SRE 維護的**規則範本庫**，涵蓋常見應用（如 MySQL, Redis, Nginx）和平台（如 Kubernetes）的最佳監控實踐。使用者可一鍵套用，並僅需填寫少量參數，即可快速建立起一套可靠的監控體系。

### 靜音規則 [靜音規則](images/12-頁面-靜音規則.png)

**功能描述**：
- 集中管理所有告警靜音規則的介面。
- 靜音規則列表的欄位包含：啟用開關、名稱、狀態、類型、匹配條件、排程、下次執行時間、創建者及操作按鈕。
- 「狀態」欄位使用 `週期生效`、`即將生效` 等彩色徽章，視覺化效果好。
- 「匹配條件」以標籤（Tags）的形式清晰地展示了靜音的範圍。
- 「排程」欄位使用了如 `每週六 02:00-04:00` 這樣易於理解的文字描述。
- 支援基於時間（定時、週期）和基於特定條件的靜音。

**相關 API 端點**：
- `GET /api/v1/silence-rules` - 獲取靜音規則列表（支援篩選和分頁）。
- `POST /api/v1/silence-rules` - 創建一個新的靜音規則。
- `PUT /api/v1/silence-rules/{id}` - 更新指定的靜音規則。
- `DELETE /api/v1/silence-rules/{id}` - 刪除指定的靜音規則。
- `PUT /api/v1/silence-rules/{id}/toggle` - 快速啟用或停用某個規則。

**UX 改善建議**：
1. **增加日曆視圖**：提供一個日曆視圖，將所有靜音規則的生效時間視覺化地標示出來，方便管理者查看排程衝突或空檔。
2. **影響評估預覽**：在建立或編輯規則時，可以預覽此規則可能影響到的告警數量或資源範圍。
3. **規則衝突檢測**：當建立一個新的靜音規則時，系統應自動檢測是否與現有規則在時間或範圍上存在重疊或衝突，並給出提示。
4. **操作歷史**：為每個規則增加一個操作歷史記錄，追蹤誰在何時對規則進行了建立、修改或刪除。
5. **範本功能**：對於常用的靜音場景（如「週末資料庫備份期間」），提供儲存為範本的功能，方便快速套用。

**Jules 的分析與建議**：

我已審閱此分析。此功能是本平台超越原生 Grafana 的**核心價值**所在。原生 Grafana 只支援一次性靜音，而本平台透過自訂排程邏輯實現的**週期性靜音**，是解決 SRE 例行維護痛點的關鍵。以下架構和建議是實現此功能的絕佳藍圖。

此功能是本平台超越原生 Grafana 的**核心價值**所在。Grafana Alerting 只支援一次性的靜音，而本平台透過自訂的排程邏輯，提供了強大的**週期性靜音 (Recurring Silences)** 功能，這對於 SRE 進行例行維護（如資料庫備份、系統更新）至關重要。

**後端架構與 API 設計 (排程器 + Grafana 代理)**：
1.  **核心引擎：自訂排程器**：
    *   後端**必須**實現一個基於 Cron 的排程器 (Scheduler)。
    *   當使用者建立一個「週期性」靜音規則時，平台將其**排程定義 (e.g., CRON 表達式、起止時間)** 存入自己的資料庫。
    *   排程器會定期（如每分鐘）檢查所有週期性規則。當發現某個規則的生效時間已到，排程器會**動態地**呼叫 Grafana 的 `POST /api/v1/silences` API，**建立一個標準的、一次性的 Grafana Silence**，其起止時間對應本次週期。
2.  **狀態計算與呈現**：
    *   UI 上顯示的「週期生效」、「即將生效」等狀態，是**平台計算的結果**，而非 Grafana 的原生狀態。
    *   `GET /api/v1/silence-rules` API 在回傳列表時，需要結合自身資料庫中的週期設定和從 Grafana 獲取的即時靜音狀態，計算出這些更友好的狀態標籤。
3.  **API 設計**：
    *   `POST /api/v1/silence-rules`：此 API 的請求體 (Payload) 需包含 `type` (`one-time` 或 `recurring`) 欄位。如果 `type` 是 `recurring`，則必須包含 `schedule` (如 CRON 字串) 和 `duration` (如 `2h`) 等欄位。
    *   `GET /api/v1/silence-rules`：API 回應中，對於週期性規則，應包含 `next_execution_time` 欄位，由後端排程器計算得出。

**UX/UI 強化建議**：
1.  **整合的 SRE 維運日曆**：將「日曆視圖」的建議提升為**整合的「SRE 維運日曆」**。在一個統一的日曆介面上，疊加顯示**靜音排程**、**團隊值班表 (On-Call)** 和**已規劃的部署/變更事件**。這將成為團隊規劃和協調工作的單一事實來源 (SSOT)。
2.  **即時的「影響評估」**：在建立或編輯靜音規則時，根據使用者輸入的匹配條件，後端應**即時查詢 Elasticsearch**，並在前端反饋「此規則在過去 24 小時內可能影響了 X 條告警」，以幫助使用者精準設定範圍，避免過度靜音。
3.  **從「事件」一鍵創建**：應提供從「事件列表」頁面為某個活躍事件**一鍵創建靜音**的快捷操作。系統需能自動提取事件的標籤作為預填的匹配條件，並提供「靜音 1 小時」、「靜音 24 小時」、「建立週期性靜音」等快速選項，極大提升應急響應效率。

---

## 2.資源管理

### 資源列表 [資源列表](images/30-頁面-資源列表.png)

**功能描述**：
- 基礎設施資源統一管理介面
- 資源統計 KPI：總資源數、健康資源、告警資源、資源群組
- 分頁視圖：資源列表、資源群組、拓撲視圖
- 資源表格：狀態、名稱、IP 位址、位置、所屬圖像、資源類型、標籤、關聯事件、CPU/記憶體使用率
- 搜尋、篩選、批次操作功能

**相關 API 端點**：
- `GET /api/v1/resources` - 獲取資源列表（支援分頁、篩選、排序）
- `GET /api/v1/resources/{id}` - 獲取資源詳情
- `PUT /api/v1/resources/{id}` - 更新資源資訊
- `DELETE /api/v1/resources/{id}` - 刪除資源
- `GET /api/v1/resources/statistics` - 資源統計數據
- `GET /api/v1/resources/{id}/metrics` - 獲取資源指標

**UX 改善建議**：
1. **即時指標**：CPU/記憶體使用率應使用動態圖表顯示歷史趨勢
2. **狀態視覺化**：使用更直觀的健康狀態指示器（心跳圖示、色彩編碼）
3. **快速操作**：增加資源快速重啟、連線、查看日誌等操作
4. **智能分組**：支援按位置、類型、狀態等維度的智能分組
5. **告警整合**：在資源列表中直接顯示相關告警數量和嚴重性

#### 編輯資源 [編輯資源](images/33-彈窗-資源列表-編輯資源.png)

**功能描述**：
- 資源編輯彈窗
- 修改資源的基本資訊和配置
- 支援資源屬性更新和標籤管理

**相關 API 端點**：
- `PUT /api/v1/resources/{id}` - 更新資源資訊

**UX 改善建議**：
1. **表單驗證**：即時驗證資源配置的有效性和格式
2. **批量編輯**：支援多個資源的批量屬性修改
3. **變更預覽**：在儲存前顯示變更對比和影響分析
4. **標籤管理**：提供直觀的標籤編輯器，支援拖拽和搜尋
5. **配置模板**：為不同類型的資源提供配置模板

**Jules 的分析與建議**：

我已審閱此分析。此彈窗是**維護 CMDB 資料品質**的關鍵互動點。圖片中展示的「標籤」編輯介面尤其出色，它透過提供建議、描述和使用次數，極大地提升了使用者體驗和資料一致性。我的建議將聚焦於**資料治理**和**智慧化**的深化。

**核心架構設計：資料治理與驗證**
1.  **處理手動與自動化的衝突**：表單中的欄位（如 `IP 位址`, `類型`）可能由自動化探索工具填充。平台必須有明確的**資料來源優先級策略**。
    *   **建議策略**：由自動化探索發現的欄位應預設為**唯讀 (Read-only)**，並在 UI 上用一個小圖示（如 🔗）標示其來源。若使用者確實需要覆寫，可以提供一個「解鎖」或「覆寫」按鈕，但此操作必須**記錄明確的審計日誌**，說明是誰在何時覆寫了自動值。
    *   後端 API (`PUT /api/v1/resources/{id}`) 必須能處理這種帶有「覆寫」標記的更新請求。
2.  **強化的後端驗證**：API 必須執行嚴格的資料驗證，例如：
    *   `ip_address` 必須符合有效的 IP 格式。
    *   `type` 必須是後台預先定義好的枚舉值之一。
    *   所有傳入的標籤鍵和值，都應與「標籤管理」模組中定義的規則進行校驗。
3.  **智慧標籤系統的後端支撐**：為了實現圖片中優秀的標籤 UI，後端需要提供：
    *   `GET /api/v1/tags/keys`: 獲取所有已定義的標籤**鍵**，及其描述。
    *   `GET /api/v1/tags/values?key=...`: 根據標籤**鍵**，獲取所有推薦的**值**及其使用次數。
    *   **強制詞彙表 (Enforced Vocabulary)**：「標籤管理」模組應允許管理員設定某個標籤鍵（如 `env`）的值**只能**從一個預設列表（`production`, `staging`, `test`）中選擇。當 UI 偵測到這種強制性標籤時，應自動將值的輸入框從「自由輸入」轉換為「**下拉選單**」，從源頭上保證資料的一致性。

**UX/UI 強化建議：提升確定性與可追溯性**
1.  **完整的審計追蹤 (Audit Trail)**：每一次透過此彈窗進行的儲存操作，都**必須**產生一條詳細的**審計日誌**。日誌應記錄 `resource_id`、操作者、時間、**所有被變更欄位的前後值對比**。在彈窗的底部，可以增加一個「查看變更歷史」的連結，直接導向該資源的審計歷史記錄。
2.  **視覺化區分資料來源**：如上所述，應在 UI 上清晰地標示出哪些欄位是使用者手動輸入的，哪些是由系統自動同步的。這有助於使用者理解資料的生命週期，避免混淆。
3.  **智慧推薦資源群組**：目前是手動勾選所屬群組。可以基於該資源的**標籤**進行智慧推薦。例如，一旦一個資源被打上了 `app:database` 和 `env:production` 的標籤，系統可以自動**建議或預先勾選**「Production Database」這個資源群組，減少使用者的操作負擔。

### 資源群組 [資源群組](images/31-頁面-資源群組.png)

**功能描述**：
- 資源邏輯分組管理
- 群組統計資訊顯示
- 群組列表：名稱、描述、負責團隊、資源數量、健康狀態統計
- 群組健康狀態分佈（Healthy/Warning/Critical）

**相關 API 端點**：
- `GET /api/v1/resource-groups` - 獲取資源群組列表
- `POST /api/v1/resource-groups` - 創建資源群組
- `PUT /api/v1/resource-groups/{id}` - 更新資源群組
- `DELETE /api/v1/resource-groups/{id}` - 刪除資源群組
- `GET /api/v1/resource-groups/{id}/resources` - 獲取群組內資源
- `POST /api/v1/resource-groups/{id}/resources` - 向群組添加資源

**UX 改善建議**：
1. **視覺化儀表板**：為每個群組提供迷你儀表板顯示關鍵指標
2. **拖拽分組**：支援拖拽方式將資源分配到不同群組
3. **階層式結構**：支援巢狀群組和子群組管理
4. **權限管理**：與團隊權限系統整合，控制群組訪問權限
5. **自動分組**：基於標籤或規則的自動分組功能

**Jules 的分析與建議**：

我已審閱此分析。資源群組是實現**「責任到人」**和**「規模化管理」**的關鍵機制。它不僅是資源的容器，更是策略、權限和監控的**作用域 (Scope)**。此處的設計為後續的深度整合奠定了良好基礎。

**核心架構設計：靜態與動態結合**
1.  **支援兩種群組類型**：平台必須同時支援兩種群組模式，以應對不同的管理需求。
    *   **靜態群組 (Static Group)**：由使用者**手動**將資源加入或移除。適用於邊界清晰、成員固定的業務服務。
    *   **動態群組 (Dynamic Group)**：基於一組**標籤匹配規則**自動更新成員。例如，一個「生產環境 Nginx」群組可以由規則 `tags.env == "production" AND tags.app == "nginx"` 來定義。任何符合此規則的新資源都會被**自動納入**。
    *   在「新增/編輯群組」的彈窗中，應提供一個切換開關來選擇群組類型。
2.  **後端實現**：
    *   `resource_groups` 資料表中需要一個 `type` 欄位 (`static` 或 `dynamic`) 和一個 `rules` 欄位 (JSONB，用於儲存動態規則)。
    *   一個背景作業需要定期執行，掃描所有動態群組的規則，並更新其成員關係快取。
3.  **API 效能**：
    *   `GET /api/v1/resource-groups` API 回應中的「狀態」統計（健康、警告、嚴重）**絕不能**即時計算。這必須由一個非同步的背景作業（如每 5 分鐘）預先計算並快取。即時計算會導致嚴重的效能問題。

**UX/UI 強化建議：群組即是迷你儀表板**
1.  **讓統計數字可操作**：群組列表中的「狀態」欄位（如 `Healthy: 1`, `Warning: 0`, `Critical: 0`）不僅是數字，更應是**可點擊的篩選器**。點擊 `Critical: 0` 應直接跳轉到資源列表頁，並自動篩選出屬於「Production Database」群組且狀態為「Critical」的資源。
2.  **增加趨勢與 SLO 視圖**：
    *   在每一行增加一個**迷你趨勢圖**，顯示該群組內 `Critical` 事件在過去 24 小時的變化趨勢。
    *   如果該群組關聯了服務等級目標 (SLO)，應在此處簡潔地顯示其**錯誤預算 (Error Budget)** 的剩餘百分比。這能為 SRE 提供極其重要的決策依據。
3.  **群組作為全域篩選器**：資源群組應成為平台中一個**通用、一致的篩選維度**。在「事件列表」、「儀表板」、「自動化日誌」等所有相關頁面，都應提供按「資源群組」進行篩選的功能。
4.  **強化責任歸屬**：
    *   「負責團隊」欄位應是一個超連結，點擊後可跳轉到該團隊的詳細資料頁面。
    *   應與通知系統整合，允許直接向某個群組的「負責團隊」發送通知。

#### 編輯群組 [編輯群組](images/34-彈窗-資源群組-編輯群組.png)

**功能描述**：
- 資源群組編輯彈窗
- 修改群組的基本資訊和成員配置
- 支援群組屬性更新和資源分配

**相關 API 端點**：
- `PUT /api/v1/resource-groups/{id}` - 更新資源群組

**UX 改善建議**：
1. **成員管理**：提供直觀的成員添加/移除界面，支援拖拽操作
2. **權限繼承**：修改群組權限時清楚顯示對成員的影響
3. **依賴關係**：顯示和管理群組間的依賴關係
4. **巢狀結構**：支援父子群組的階層式管理
5. **活動日誌**：記錄和顯示群組的變更歷史

**Jules 的分析與建議**：

我已審閱此分析。此彈窗是定義**管理邊界**和**責任範圍**的核心介面。圖片中展示的雙欄選擇器 (Dual Listbox) 是管理**靜態群組**成員的經典作法。我的建議旨在引入**動態群組**的配置能力，並提升大規模環境下的可用性。

**核心架構設計：引入動態群組的配置**
1.  **引入模式切換 (Mode Switcher)**：這是最重要的架構升級。在彈窗頂部，應增加一個**模式切換器**（如分段控制器），包含兩個選項：
    *   **「手動管理」**：選中時，顯示圖片中現有的雙欄選擇器，用於手動添加/移除資源。
    *   **「規則管理」**：選中時，雙欄選擇器應被**替換**為一個**規則產生器 (Rule Builder)** 介面。此介面允許使用者定義一組基於**標籤**的匹配條件（如 `tags.env == "production" AND tags.app == "database"`）。
2.  **規則管理的即時預覽**：在「規則管理」模式下，介面下方應有一個區域**即時預覽**目前符合規則的資源列表。這能讓使用者在儲存前，驗證其規則的準確性。
3.  **靈活的後端 API**：`PUT /api/v1/resource-groups/{id}` API 的請求體 (Payload) 必須能夠靈活處理兩種模式：
    *   若為手動模式，Payload 應包含一個 `resource_ids` 陣列。
    *   若為規則模式，Payload 則應包含一個 `rules` 物件（例如 `{"operator": "AND", "conditions": [{"key": "tags.env", "op": "==", "value": "production"}]}`）。

**UX/UI 強化建議：應對規模化挑戰**
1.  **雙欄選擇器的延展性 (Scalability)**：當「可用資源」數量龐大時（數千個），目前的 UI 會失效。必須進行強化：
    *   **後端分頁與搜尋**：兩個列表都必須實現**後端分頁**。使用者的捲動或點擊頁碼時，才向後端請求下一頁資料。
    *   **進階篩選**：「可用資源」列表上方的搜尋框，不應只是一個簡單的文字搜尋。它應該是一個**進階篩選器**，允許使用者按資源**類型、狀態、標籤**等進行篩選，以快速找到他們想要添加的資源。
2.  **明確化「負責團隊」的權責**：變更「負責團隊」是一個高風險操作，它直接影響到權限和通知。當使用者試圖修改此欄位時，應彈出一個**確認對話框**，明確告知其後果，例如：「您確定要將負責團隊變更為『資料庫團隊』嗎？該團隊的成員將獲得此群組內所有資源的管理權限。」
3.  **與拓撲視圖的聯動**：在彈窗底部增加一個「**在拓撲圖中預覽**」按鈕。點擊後，可以在背景打開拓撲視圖，並高亮顯示當前群組的所有成員及其相互關係。這有助於使用者從架構的角度，審視群組成員的合理性。

### 資源拓撲 [拓撲視圖](images/32-頁面-拓撲視圖.png)

**功能描述**：
- 資源關係拓撲圖視覺化
- 互動式網絡圖顯示資源依賴關係
- 節點類型色彩編碼（資料庫、伺服器、網路、快取、監控等）
- 力導向佈局演算法
- 操作說明和圖例

**相關 API 端點**：
- `GET /api/v1/topology/nodes` - 獲取拓撲節點數據
- `GET /api/v1/topology/edges` - 獲取拓撲連接關係
- `GET /api/v1/topology/layout/{type}` - 獲取特定佈局的拓撲數據
- `POST /api/v1/topology/analyze` - 執行拓撲分析

**UX 改善建議**：
1. **多層級視圖**：支援縮放查看不同層級的拓撲詳情
2. **實時狀態**：節點顏色即時反映健康狀態和告警
3. **路徑分析**：點擊節點顯示影響路徑和依賴鏈
4. **佈局選項**：提供多種佈局演算法選擇（樹狀、環形、層次等）
5. **篩選功能**：支援按類型、狀態、團隊等條件篩選顯示節點

**Jules 的分析與建議**：

我已審閱此分析。拓撲視圖不應只是一個靜態的架構圖，而應是一個**即時的、互動式的診斷儀表板**。它的核心價值在於將**抽象的依賴關係**與**即時的健康狀態**結合，幫助 SRE 快速定位問題根源和評估影響範圍。

**核心架構設計：CMDB 作為單一事實來源 (SSOT)**
1.  **數據來源必須是 CMDB**：此拓撲圖的品質完全取決於 CMDB 中**關係資料**的準確性。後端必須有一個清晰的資料庫模型來儲存節點（`nodes`，即 `resources` 表中的資源）和邊（`edges`）。`edges` 表應至少包含 `source_resource_id`, `target_resource_id` 和 `relationship_type`（如 `CONNECTS_TO`, `DEPENDS_ON`）等欄位。
2.  **關係的維護**：平台必須提供維護這些關係資料的機制，理想情況下應結合：
    *   **手動編輯介面**：允許架構師或 SRE 手動定義服務間的依賴關係。
    *   **自動化探索 API**：提供 API 端點，讓外部的服務網格 (Service Mesh) 或網路監控工具可以將自動探索到的依賴關係推送至 CMDB。
3.  **API 設計：分離靜態與動態資料**：
    *   `GET /api/v1/topology?resource_group=...`：此 API 應用於獲取**靜態**的拓撲結構（節點和邊）。它必須支援按「資源群組」進行篩選，因為全域拓撲圖通常資訊量過大而難以使用。
    *   **即時狀態推送 (WebSocket)**：前端在繪製出靜態拓撲圖後，應透過 WebSocket 訂閱可見節點的**健康狀態更新**。後端的一個服務會持續監控資源狀態，並在狀態變更時，將更新即時推送給前端。這種方式遠優於前端的輪詢。

**UX/UI 強化建議：從「看圖」到「診斷」**
1.  **健康狀態是第一視覺元素**：節點的顏色**不應**固定為其類型顏色。節點的**邊框顏色**應動態反映其**即時健康狀態**：`綠色`代表健康，`黃色`代表警告，`紅色`且**帶有脈衝動畫**代表嚴重。這能讓 SRE 在一秒內識別出問題節點。節點中心的圖示則可以保留其類型標識。
2.  **互動式故障分析**：這是拓撲圖的核心價值。當使用者點擊一個**紅色**節點時：
    *   **視覺化爆炸半徑 (Blast Radius)**：圖中所有與該故障節點**無關**的節點和連線都應**變暗**。所有**下游**的依賴節點應被高亮，清晰地展示出此次故障的**影響範圍**。
    *   **視覺化上游依賴 (Upstream Dependencies)**：同時，所有**上游**的依賴節點也應被高亮，但使用不同的樣式（例如虛線高亮）。這為 SRE 提供了尋找**根本原因**的線索。
3.  **邊 (Edge) 也是資訊載體**：不僅節點，節點之間的連線也應承載資訊。滑鼠懸停在連線上時，應顯示一個小彈窗，展示兩個服務間的關鍵指標，如**流量 (RPM)**、**錯誤率 (%)** 和 **延遲 (Latency)**。這些資料可以從服務網格或 APM 系統中獲取。
4.  **提供「時間旅行」功能**：在介面下方增加一個時間滑桿，允許使用者回溯到過去的某個時間點（例如，事故發生時），查看當時的拓撲健康狀態快照。這對於事後複盤和理解故障演變過程非常有幫助。

---

## 3.儀表板

### 儀表板管理 [儀表板管理](images/40-頁面-儀表板管理.png)

**功能描述**：
- 儀表板管理入口頁面
- 預設儀表板：基礎設施洞察
- 業務儀表板：SRE 戰情室

**相關 API 端點**：
- `GET /api/v1/dashboards` - 獲取儀表板列表
- `GET /api/v1/dashboards/{id}` - 獲取特定儀表板
- `POST /api/v1/dashboards` - 創建新儀表板
- `PUT /api/v1/dashboards/{id}` - 更新儀表板
- `DELETE /api/v1/dashboards/{id}` - 刪除儀表板

**UX 改善建議**：
1. **卡片設計優化**：增加儀表板預覽圖或圖示
2. **快捷操作**：增加「設為預設」、「複製」、「分享」等快捷操作
3. **分類管理**：支援儀表板分類和標籤功能
4. **搜尋功能**：增加儀表板搜尋和過濾功能
5. **使用統計**：顯示儀表板使用頻率和最後訪問時間

**Jules 的分析與建議**：

我已審閱此分析。此頁面是平台的**視覺化中樞入口**。根據 `architecture.md` 的指導原則，本平台不重複造輪子，而是作為 **Grafana 的智慧型抽象層**。因此，此頁面的核心是**管理與呈現**在 Grafana 中定義的儀表板，而非在本機重建。

**核心架構設計：Grafana 的門戶 (Portal)**
1.  **資料庫作為門戶索引**：本平台的後端資料庫 (PostgreSQL) 中應有一張 `dashboards` 表。此表不儲存儀表板的 JSON 內容，而是作為一個**索引或門戶**，儲存儀表板的**元資料**，核心欄位包括：
    *   `title`: 在本平台顯示的友善名稱。
    *   `description`: 功能描述。
    *   `category`: 用於 UI 分類（如 `資源監控`, `業務監控`）。
    *   `grafana_uid`: **最重要的欄位**，儲存對應的 Grafana 儀表板的唯一識別碼 (UID)。
    *   `grafana_url`: (可選) 儀表板的直接 URL，用於嵌入。
2.  **透過 `<iframe>` 嵌入**：當使用者點擊任何一個儀表板卡片時，前端不應嘗試自己去渲染圖表。而應導航到一個通用的儀表板檢視頁面，該頁面內嵌一個 `<iframe>`，其 `src` 指向對應的 Grafana 儀表板 URL，並帶上 `kiosk` 模式參數以隱藏 Grafana 自身的 UI 元素，實現無縫整合。
3.  **權限代理**：本平台應提供統一的權限管理。當使用者試圖存取某儀表板時，本平台的後端應先檢查該使用者是否有權限（根據 `dashboards` 表的元資料），驗證通過後，才回傳包含 Grafana `src` 的頁面。這實現了比 Grafana 原生更靈活的權限控制。

**UX/UI 強化建議：從「列表」到「工廠」**
1.  **儀表板即代碼 (Dashboard as Code) 與範本化**：提供一個「**從範本新增**」的功能。管理員可以預先定義好適用於不同場景的**儀表板範本**（例如，「標準微服務監控範本」）。當需要為一個新服務建立儀表板時，使用者只需選擇該範本，並提供一些參數（如 `服務名稱`、`資源群組`），後端就會自動呼叫 Grafana API，**動態產生並部署**一個新的儀表板。
2.  **個人化與我的最愛**：
    *   允許使用者將任何儀表板「**釘選**」或「**加入我的最愛**」。頁面頂部應有一個「我的最愛」區域，優先顯示這些個人化的捷徑。
    *   「預設首頁」應可由使用者在個人設定中**自行指定**。
3.  **豐富化卡片資訊**：目前的卡片資訊略顯單薄。可以增加：
    *   **儀表板縮圖**：後端可以定期對 Grafana 儀表板進行截圖，作為預覽圖顯示在卡片上。
    *   **擁有者/團隊**：顯示該儀表板的負責團隊。
    *   **標籤**：為儀表板本身也加上標籤，並提供按標籤篩選的功能。

### 基礎設施洞察 [基礎設施洞察](images/41-頁面-基礎設施洞察.png)

**功能描述**：
- 基礎設施狀態監控儀表板
- 關鍵指標 KPI：伺服器總數、資料庫數量、容器數量、服務數量
- 資源列表總覽（顯示 374 個資源）
- 詳細尋求（使用率排行）：各資源的使用率條狀圖顯示
- AI 風險預測：識別高風險資源和建議
- 需關注的資源列表：按嚴重性分類顯示

**相關 API 端點**：
- `GET /api/v1/analytics/infrastructure/overview` - 基礎設施概覽數據
- `GET /api/v1/analytics/infrastructure/utilization` - 資源使用率排行
- `GET /api/v1/analytics/infrastructure/predictions` - AI 風險預測
- `GET /api/v1/analytics/infrastructure/alerts` - 需關注資源列表

**UX 改善建議**：
1. **即時更新**：使用率條狀圖應支援即時更新和歷史趨勢查看
2. **互動式導航**：點擊資源可跳轉到詳細監控頁面
3. **自定義閾值**：允許人員設定使用率警告和危險閾值
4. **預測準確性**：顯示 AI 預測的置信度和歷史準確率
5. **快速操作**：為高使用率資源提供快速擴容或優化建議

**Jules 的分析與建議**：

我已審閱此分析。此儀表板是 SRE 的**日常起點**，旨在提供一個關於基礎設施健康狀況的**高密度資訊概覽**。它完美地體現了本平台「統一管理平面」的價值——將來自 CMDB、監控系統和 AI 引擎的資料聚合在一個視圖中。

**核心架構設計：一個被精心編排的 Grafana 儀表板**
1.  **單一 Grafana 儀表板**：整個「基礎設施洞察」頁面本身就應該是一個**單一的、經過精心設計的 Grafana 儀表板**，然後被無縫嵌入到本平台中。平台負責管理其生命週期和存取權限。
2.  **Grafana 的多源數據能力**：為了實現此儀表板，Grafana 必須被配置為可以從本平台的**所有相關數據源**中拉取資料：
    *   **VictoriaMetrics**：用於「資源列表總覽」中的使用率指標。
    *   **PostgreSQL**：Grafana 需要安裝 `PostgreSQL` 資料來源外掛程式，使其能夠直接查詢本平台的 CMDB 資料庫，以獲取頂部的 KPI 計數（如伺服器總數）和「需關注的資源列表」。
    *   **AI 預測資料庫**：AI 引擎在進行風險預測後，應將其結構化的結果（`resource_id`, `prediction_text`, `confidence`, `risk_level`, `timestamp`）寫入一個專門的資料庫表（可以是 PostgreSQL 中的一張新表）。Grafana 透過查詢此表來填充「AI 風險預測」面板。
3.  **API 的角色轉變**：本平台的後端 API 在此處的角色**不是**為前端提供渲染儀表板所需的所有資料。相反，它的職責是**為 Grafana 提供可查詢的資料端點**，或者確保 Grafana 能夠安全地直連到後端資料庫。

**UX/UI 強化建議：萬物皆可下鑽 (Drill-Down)**
1.  **無處不在的下鑽連結**：此儀表板上的**每一個數據點**都應該是一個下鑽的入口，以實現從「發現問題」到「定位問題」的無縫跳轉。
    *   點擊頂部的 KPI（如「47 台伺服器」），應跳轉到**資源列表**頁面，並預先篩選好 `type=server`。
    *   點擊「資源列表總覽」中的任何一個資源，應跳轉到該資源**專屬的、更詳細的監控儀表板**（這也是一個 Grafana 儀表板）。
    *   點擊「AI 風險預測」中的一個條目，應彈出一個對話框，用**圖表**展示AI做出此預測的**依據**（例如，CPU 使用率的歷史趨勢圖和未來預測的擬合曲線）。
    *   點擊「需關注的資源列表」中的一個資源，應跳轉到**事件列表**頁面，並預先篩選好該資源的所有活躍事件。
2.  **賦予 AI 預測可解釋性**：AI 預測如果是一個黑盒子，就很難獲得 SRE 的信任。在每個預測旁邊，應增加一個「**查看詳情**」或「**解釋**」的按鈕。點擊後，展示用於推斷的關鍵指標圖表和分析摘要，讓 SRE 能夠理解和驗證預測的邏輯。
3.  **全局時間範圍選擇器**：作為一個合格的儀表板，頁面頂部必須有一個**時間範圍選擇器**（如「過去 1 小時」、「過去 24 小時」）。這個選擇器會作為變數，傳遞給頁面中所有的 Grafana 面板，確保所有資料都在統一的時間維度下進行展示。

### SRE 戰情室 [SRE戰情室](images/42-頁面-SRE戰情室.png)

**功能描述**：
- 系統狀態總覽儀表板
- 即時事件統計卡片：待處理事件、處理中、今日已解決
- AI 每日簡報文字摘要
- 服務健康度總覽（堆疊條狀圖）
- 資源群組狀態總覽（分組條狀圖）

**相關 API 端點**：
- `GET /api/v1/dashboard/overview` - 首頁統計數據
- `GET /api/v1/events/summary` - 事件統計摘要
- `GET /api/v1/ai/daily-report` - AI 每日簡報
- `GET /api/v1/resources/health-summary` - 服務健康度摘要
- `GET /api/v1/resource-groups/status-summary` - 資源群組狀態摘要

**UX 改善建議**：
1. **視覺層次優化**：KPI 卡片數值應更突出，考慮增大字體並調整色彩對比
2. **互動性增強**：KPI 卡片應可點擊深入查看詳細資訊
3. **AI 簡報改善**：增加展開/收合功能，提供更詳細的分析內容
4. **圖表優化**：條狀圖應支援 hover 顯示具體數值
5. **實時更新**：增加自動刷新功能和最後更新時間顯示

**Jules 的分析與建議**：

我已審閱此分析。此「戰情室」儀表板是整個平台的**大腦和心臟**，其設計目標是從**業務視角**出發，回答「系統現在好不好？」和「我應該立即關注什麼？」這兩個核心問題。

**核心架構設計：以「業務服務」為核心的 Grafana 儀表板**
1.  **引入「業務服務」的抽象層**：為了實現「服務健康度總覽」，CMDB 中必須引入一個比「資源群組」更高層次的抽象——**「業務服務 (Business Service)」**。一個「業務服務」（如 `支付服務`）可以由**多個**「資源群組」（如 `支付API伺服器群組`、`支付資料庫群組`）組成。
2.  **基於 SLO 的健康度計算**：圖中的「服務健康度總覽」熱圖，其顏色（健康/警告/嚴重）的依據應來自於**服務等級目標 (SLO)**。後端需要有一個服務，能夠：
    *   為每個「業務服務」的每個監控維度（延遲、流量、錯誤、飽和度）定義 SLO。
    *   持續計算當前的效能指標是否違反了 SLO。
    *   將計算出的健康狀態結果存入資料庫，供 Grafana 查詢。
3.  **AI 簡報的生成與呈現**：
    *   後端的 AI Agent 應定期（如每小時）執行一個分析任務，掃描過去一小時的指標和事件，生成這段文字摘要。
    *   摘要內容應包含 **Markdown** 格式的連結，以便在前端實現可點擊的跳轉。
    *   `GET /api/v1/ai/daily-report` API 只需回傳儲存在資料庫中的最新簡報即可。

**UX/UI 強化建議：將儀表板變為指揮中心**
1.  **完全互動的熱圖 (Interactive Heatmap)**：熱圖是此儀表板的靈魂，它的每一個單元格都必須是可操作的。
    *   **點擊單元格**：例如，點擊「支付服務」在「錯誤」維度的紅色格子，應能立即**下鑽 (Drill Down)** 到一個專門的、預先篩選好的儀表板，詳細展示「支付服務」的錯誤日誌、錯誤率趨勢和相關事件。
    *   **懸停顯示細節 (Hover)**：滑鼠懸停在任何一個格子上，都應顯示一個工具提示，包含**當前的具體指標值**和觸發狀態變更的 **SLO 閾值**（例如，「錯誤率: 2.1% (閾值: >1%)」）。
2.  **可操作的 AI 簡報**：簡報中的實體（如 `Production Web Servers`, `web-prod-03`）必須是**可點擊的超連結**，直接將 SRE 導向對應的資源群組儀表板或資源詳情頁面，實現從「閱讀」到「行動」的轉化。
3.  **整合值班資訊 (On-Call Integration)**：戰情室最重要的資訊之一就是「誰能解決問題」。儀表板的顯著位置（例如右上角）應有一個**值班資訊面板**，顯示關鍵業務服務的**當前主/備值班人員**是誰，並提供一鍵聯絡（如點擊跳轉到 Slack）的功能。此資訊可透過 API 從 Grafana OnCall 或 PagerDuty 等工具同步。
4.  **即時性是關鍵**：頂部的事件計數器等關鍵指標，必須透過 **WebSocket** 實現即時更新，確保戰情室的資訊沒有延遲。

---

## 4.分析中心

### 容量規劃 [容量規劃](images/50-頁面-容量規劃.png)

**功能描述**：
- 容量規劃分析工具
- 分析統計 KPI：數據點總數、分析報告數、處理時間、準確率
- 分析類型導航：容量規劃、性能洞察、異常檢測、成本分析、MTTR 分析、SLA 報告
- 資源群組和效能指標選擇器
- 目前使用率顯示（65.53%）
- 趨勢預測圖表：歷史數據和預測趨勢線
- 容量預警：預計達到 80% 警戒線的時間
- 分析建議：具體的容量規劃建議和自動化腳本

**相關 API 端點**：
- `GET /api/v1/analytics/capacity/overview` - 容量規劃概覽
- `GET /api/v1/analytics/capacity/predictions` - 容量預測數據
- `GET /api/v1/analytics/capacity/recommendations` - 容量建議
- `POST /api/v1/analytics/capacity/analyze` - 執行容量分析
- `GET /api/v1/analytics/capacity/trends` - 容量趨勢數據

**UX 改善建議**：
1. **場景規劃**：支援多種增長場景的容量規劃（樂觀、悲觀、現實）
2. **成本估算**：整合成本計算，顯示容量擴展的預算影響
3. **自動化建議**：將建議直接轉換為可執行的自動化腳本
4. **協作功能**：支援規劃報告的分享和團隊協作審查
5. **警報整合**：設定容量閾值警報和提前通知機制

**Jules 的分析與建議**：

我已審閱此頁面設計。容量規劃是 SRE 從被動救火轉向主動預防的關鍵工具。此設計在視覺化和建議方面做得很好，但要將其從「報告」轉變為一個可信、可操作的「決策支援系統」，我們必須在後端架構、API 設計和前端互動性上進行深度強化。

**後端架構與資料流程**：
1.  **資料來源與時序資料庫**：
    *   **資料來源**：此功能的所有歷史資料**必須**來自 `architecture.md` 中定義的 **VictoriaMetrics** 時序資料庫。
    *   **查詢語言**：後端應使用 MetricsQL 進行高效的資料聚合查詢。
2.  **非同步分析服務 (Async Analysis Service)**：
    *   容量預測是一個計算密集型任務，**嚴禁**在 API 請求中即時計算。
    *   應建立一個獨立的 Go **分析服務 (Analytics Service)**。此服務應透過背景排程作業（例如，每 24 小時）為所有關鍵資源和指標**預先計算**未來 90 天的趨勢預測。
    *   預測結果（包括趨勢資料點、達到閾值的預計天數等）應被儲存在 **PostgreSQL** 資料庫的 `capacity_predictions` 表中，供 API 快速查詢。
3.  **KPI 指標預計算**：頂部的 KPI 指標（數據點總數、準確率等）同樣需要由背景作業**預先計算並快取**在 Redis 中，以確保頁面載入速度。

**API 設計**：
*   `POST /api/v1/analytics/capacity/analyze`：此 API 不應觸發即時的、阻塞式的分析。它的職責是**提交一個非同步的分析任務**。後端應立即回傳一個 `task_id`，前端可使用此 ID 輪詢任務狀態或透過 WebSocket 接收完成通知。
*   `GET /api/v1/analytics/capacity/trends?resource_group=...&metric=...`：此 API 應**直接查詢** PostgreSQL 中預先計算好的預測結果，以實現儀表板的秒級載入。其回傳應包含歷史資料和預測資料。
*   `GET /api/v1/analytics/capacity/recommendations?prediction_id=...`：基於一個已完成的預測任務，獲取結構化的建議。回傳的 JSON 應包含建議文字和可執行的 `script_id`。

**UX/UI 強化建議**：
1.  **信任度與透明度**：
    *   **顯示模型與信賴區間**：在「趨勢預測」圖表中，除了預測線，還應繪製出**信賴區間 (Confidence Interval)** 的陰影區域。並在圖表下方用小字註明使用的預測模型（如 ARIMA），這能極大提升 SRE 對預測結果的信任度。
    *   **資料點回溯**：圖表應支援互動。使用者點擊圖表上的任一歷史資料點時，應能看到該時間點的原始指標快照或關聯的重大事件，幫助理解歷史趨勢的成因。
2.  **情境化的自動化 (Contextual Automation)**：
    *   「建議執行擴容腳本」按鈕是個亮點。應將其強化：點擊後，不應直接執行，而是彈出一個**參數預填的執行確認視窗**。例如，若建議是「增加 2 個 Web Server」，則彈窗中的腳本參數 `instance_count` 應預設填寫為 `2`。
    *   此處應**提供多個推薦腳本**，而不只是一個。例如，除了「擴容」，還可能有關聯的「效能優化」或「資料清理」腳本可供選擇。
3.  **What-If 分析模擬**：
    *   提供一個「**模擬事件**」輸入功能。例如，使用者可以輸入「預計下月流量增長 50%」，後端分析服務接收此參數後，重新計算並在圖表上繪製一條**新的模擬預測線**。這個 What-If 分析能力，能將工具從「回顧」提升到真正的「規劃」層次。

---

## 5.自動化中心

### 腳本庫 [腳本庫](images/51-頁面-腳本庫.png)

**功能描述**：
- 自動化腳本集中管理平台
- 自動化統計 KPI：腳本總數、執行成功率、24小時執行次數、排程任務數
- 最近執行日誌監控面板
- 熱門腳本排行榜（按執行次數）
- 腳本分類導航：腳本庫、四游程管理、執行日誌
- 腳本表格：名稱、類型、創建者、排程引用、描述

**相關 API 端點**：
- `GET /api/v1/scripts` - 獲取腳本列表
- `POST /api/v1/scripts` - 創建新腳本
- `PUT /api/v1/scripts/{id}` - 更新腳本
- `DELETE /api/v1/scripts/{id}` - 刪除腳本
- `POST /api/v1/scripts/{id}/execute` - 執行腳本
- `GET /api/v1/scripts/statistics` - 腳本統計數據

**UX 改善建議**：
1. **腳本編輯器**：內建代碼編輯器，支援語法高亮和自動補全
2. **版本控制**：腳本版本管理和回滾功能
3. **測試環境**：提供腳本測試和調試環境
4. **依賴管理**：顯示腳本間的依賴關係
5. **協作功能**：支援腳本分享和團隊協作開發

**Jules 的分析與建議**：

我已審閱此頁面設計。腳本庫是 SRE 平台實現「自動化」價值的核心，是將人類知識轉化為可重複執行資產的關鍵場所。此頁面佈局清晰，但要使其成為一個安全、可靠、可治理的企業級功能，我們必須在後端架構、API 設計和 UX 上進行深度強化。

**後端架構與設計**：
1.  **腳本儲存策略：Git-as-a-Database**
    *   **嚴禁**將腳本內容直接儲存在 PostgreSQL 中。這會導致版本控制混亂、缺乏審計追蹤，且難以進行程式碼審查 (Code Review)。
    *   **正確做法**：後端應整合一個私有的 **Git 倉庫** (如 Gitea 或 GitLab) 作為腳本的「單一事實來源 (SSOT)」。
    *   `scripts` 資料表在 PostgreSQL 中僅儲存**元數據** (metadata)，如 `script_name`, `description`, `creator_id`，以及最重要的 `git_repo_url` 和 `commit_hash`。
2.  **非同步執行引擎**：
    *   腳本執行**必須**是**非同步**的。後端應維護一個基於訊息佇列 (e.g., Redis Streams) 的**任務執行器池 (Worker Pool)**。
    *   當使用者點擊「執行」時，API 僅是將一個「執行任務」推送到佇列中。Worker 從佇列中獲取任務，從 Git 倉庫拉取對應 `commit_hash` 的腳本內容，在一個**隔離的執行環境** (如 Docker 容器或 k8s Job) 中執行，並將執行日誌串流式地寫入 Elasticsearch。
3.  **KPI 指標預計算**：頂部的 KPI 指標（成功率、執行次數等）必須由一個背景排程作業**預先計算並快取**在 Redis 中，絕不能在頁面載入時對日誌進行即時聚合查詢。

**API 設計**：
*   `POST /api/v1/scripts`：建立一個新腳本。後端接收到腳本內容後，應執行 `git commit` 和 `git push` 到內部倉庫，然後將元數據寫入資料庫。
*   `POST /api/v1/scripts/{id}/execute`：提交一個**非同步執行任務**。請求體應包含執行參數。API 應立即回傳一個 `execution_id`，前端可使用此 ID 跳轉到該次執行的即時日誌頁面。
*   `GET /api/v1/scripts/{id}/history`：(新建議) 獲取一個腳本的 **Git 提交歷史**，用於在 UI 上展現版本演進。
*   `GET /api/v1/scripts/statistics`：從 Redis 快取中直接讀取預先計算好的 KPI 統計資料。

**UX/UI 強化建議**：
1.  **內建程式碼編輯器與版本控制**：
    *   「編輯腳本」彈窗應內嵌一個功能強大的**網頁版 IDE** (如 Monaco Editor，VS Code 的核心)，提供語法高亮、自動補全和靜態檢查功能。
    *   編輯器旁應有一個**版本歷史**分頁，清晰地展示每一次的 `git commit` 紀錄（包含提交者、時間和訊息）。使用者應能**比較任意兩個版本之間的差異 (diff)**，並能**一鍵還原**到任一歷史版本。
2.  **安全與治理**：
    *   **參數化與祕密管理**：腳本內容**嚴禁**硬編碼任何密碼、API 金鑰或 Token。平台應與 **HashiCorp Vault** 或類似的祕密管理工具整合。在腳本執行時，執行器負責從 Vault 中安全地注入所需的祕密。
    *   **執行權限 (Execution Permissions)**：應引入基於角色的腳本**執行權限**。例如，只有「資料庫管理員」角色的成員才能執行標記為 `db-sensitive` 的腳本。
3.  **提升易用性與協作**：
    *   **測試與「試運行 (Dry Run)」**：為每個腳本提供一個「測試」按鈕。同時，腳本應支援「試運行模式」，在該模式下，腳本只打印將要執行的命令，而不實際執行，以供使用者驗證其行為。
    *   **共享與審查**：提供將腳本分享給其他團隊成員進行審查的功能，整合一個簡易的程式碼審查流程。

#### 編輯腳本 [編輯腳本](images/54-彈窗-腳本庫-編輯腳本.png)

**功能描述**：
- 腳本編輯彈窗
- 支援多標籤頁編輯（基本信息、腳本內容、參數設定）
- 提供代碼語法高亮和自動補全

**相關 API 端點**：
- `PUT /api/v1/scripts/{id}` - 更新腳本

**UX 改善建議**：
1. **功能完善**：根據具體功能需求提供相應的UX改善建議
2. **使用者體驗優化**：改善界面交互和操作流程
3. **可及性改善**：提升界面的可及性和易用性
4. **性能優化**：優化載入速度和響應時間
5. **錯誤處理**：完善錯誤提示和異常情況處理

**Jules 的分析與建議**：

我已審閱此抽屜設計。日誌詳情是 SRE 工程師排查自動化問題時花費時間最多的地方，其設計的優劣直接決定了平台的易用性和排錯效率。此設計已經包含了日誌等級篩選、搜尋等高級功能，非常出色。我的建議將聚焦於如何從架構和 UX 細節上，將其打磨得盡善盡美。

**後端架構與設計**：
1.  **資料來源：Elasticsearch**
    *   後端**必須**從 **Elasticsearch** 中獲取指定 `execution_id` 的日誌文件 (Document)。此文件應包含所有元數據以及完整的 `output` 欄位。
2.  **日誌等級篩選的實現**：
    *   UI 上的「日誌等級」篩選**不應**在前端完成。前端篩選對於超大日誌會導致瀏覽器卡頓。
    *   正確做法是：當使用者選擇一個日誌等級（如 `ERROR`）時，前端應重新呼叫 API，並附上篩選參數。後端將此條件轉換為 Elasticsearch 的查詢（例如，使用 `match` 查詢來過濾 `output` 欄位中包含 `ERROR` 字串的行），只回傳符合條件的日誌內容。

**API 設計**：
*   `GET /api/v1/execution-logs/{id}`：此 API 應作為此抽屜的主要資料來源。
    *   它應回傳一個包含所有元數據（`script_name`, `status`, `duration_ms` 等）和日誌輸出 (`output`) 的 JSON 物件。
    *   可選地，它可以接受查詢參數 `?log_level=ERROR` 或 `?q=keyword`，讓後端直接在 Elasticsearch 中完成篩選和搜尋，只回傳處理過的 `output`。
*   `GET /api/v1/execution-logs/{id}/raw`：(新建議) 提供一個專門的端點，用於以 `text/plain` 格式下載完整的、未經處理的原始日誌檔案，方便使用者在本地使用 `grep` 等工具進行分析。

**UX/UI 強化建議**：
1.  **升級為真實的日誌檢視器 (Log Viewer)**：
    *   目前的純文字展示區應升級為一個**虛擬化 (Virtualized)** 的日誌檢視器元件。虛擬化是處理大量日誌（數千至數萬行）而不會造成瀏覽器卡頓的**唯一**可行方案。
    *   檢視器應對日誌行中的關鍵字（如 `ERROR`, `WARN`, `SUCCESS`, `panic`）和常見格式（如 JSON）進行**語法高亮**，極大提升可讀性。
2.  **上下文的深度連結**：
    *   抽屜頂部的所有元數據都應是可互動的：
        *   點擊「腳本名稱」，應在新分頁中打開該腳本的編輯器，並定位到執行的具體 `commit_hash` 版本。
        *   點擊「觸發方式」中的「`手動 (admin)`」，應能看到該使用者的簡要資訊。如果觸發方式是「事件」或「排程」，則應連結到對應的事件詳情或排程設定。
3.  **增強的搜尋與篩選**：
    *   搜尋框應支援**正則表達式**和**大小寫切換**選項。
    *   當執行搜尋後，除了高亮匹配行，還應在檢視器的捲動條上標示出所有匹配項的位置，方便使用者快速定位。
4.  **顯示執行參數**：
    *   在元數據區域，必須增加一塊區域，清晰地展示**本次執行所使用的完整參數**。這對於理解腳本行為和復現問題至關重要。

**Jules 的分析與建議**：

我已審閱此抽屜設計。日誌詳情是 SRE 工程師排查自動化問題時花費時間最多的地方，其設計的優劣直接決定了平台的易用性和排錯效率。此設計已經包含了日誌等級篩選、搜尋等高級功能，非常出色。我的建議將聚焦於如何從架構和 UX 細節上，將其打磨得盡善盡美。

**後端架構與設計**：
1.  **資料來源：Elasticsearch**
    *   後端**必須**從 **Elasticsearch** 中獲取指定 `execution_id` 的日誌文件 (Document)。此文件應包含所有元數據以及完整的 `output` 欄位。
2.  **日誌等級篩選的實現**：
    *   UI 上的「日誌等級」篩選**不應**在前端完成。前端篩選對於超大日誌會導致瀏覽器卡頓。
    *   正確做法是：當使用者選擇一個日誌等級（如 `ERROR`）時，前端應重新呼叫 API，並附上篩選參數。後端將此條件轉換為 Elasticsearch 的查詢（例如，使用 `match` 查詢來過濾 `output` 欄位中包含 `ERROR` 字串的行），只回傳符合條件的日誌內容。

**API 設計**：
*   `GET /api/v1/execution-logs/{id}`：此 API 應作為此抽屜的主要資料來源。
    *   它應回傳一個包含所有元數據（`script_name`, `status`, `duration_ms` 等）和日誌輸出 (`output`) 的 JSON 物件。
    *   可選地，它可以接受查詢參數 `?log_level=ERROR` 或 `?q=keyword`，讓後端直接在 Elasticsearch 中完成篩選和搜尋，只回傳處理過的 `output`。
*   `GET /api/v1/execution-logs/{id}/raw`：(新建議) 提供一個專門的端點，用於以 `text/plain` 格式下載完整的、未經處理的原始日誌檔案，方便使用者在本地使用 `grep` 等工具進行分析。

**UX/UI 強化建議**：
1.  **升級為真實的日誌檢視器 (Log Viewer)**：
    *   目前的純文字展示區應升級為一個**虛擬化 (Virtualized)** 的日誌檢視器元件。虛擬化是處理大量日誌（數千至數萬行）而不會造成瀏覽器卡頓的**唯一**可行方案。
    *   檢視器應對日誌行中的關鍵字（如 `ERROR`, `WARN`, `SUCCESS`, `panic`）和常見格式（如 JSON）進行**語法高亮**，極大提升可讀性。
2.  **上下文的深度連結**：
    *   抽屜頂部的所有元數據都應是可互動的：
        *   點擊「腳本名稱」，應在新分頁中打開該腳本的編輯器，並定位到執行的具體 `commit_hash` 版本。
        *   點擊「觸發方式」中的「`手動 (admin)`」，應能看到該使用者的簡要資訊。如果觸發方式是「事件」或「排程」，則應連結到對應的事件詳情或排程設定。
3.  **增強的搜尋與篩選**：
    *   搜尋框應支援**正則表達式**和**大小寫切換**選項。
    *   當執行搜尋後，除了高亮匹配行，還應在檢視器的捲動條上標示出所有匹配項的位置，方便使用者快速定位。
4.  **顯示執行參數**：
    *   在元數據區域，必須增加一塊區域，清晰地展示**本次執行所使用的完整參數**。這對於理解腳本行為和復現問題至關重要。

**Jules 的分析與建議**：

我已審閱此彈窗設計。這是自動化中心的核心互動介面之一，是 SRE 專家知識的「寫入點」。目前的表單佈局很清晰，但我們可以透過引入專業開發工具的實踐，將其從一個簡單的「文字編輯器」升級為一個可靠、可追溯的「程式碼編輯器」。

**後端架構與 Git 整合**：
1.  **儲存即提交 (Save is Commit)**：
    *   當使用者點擊「儲存」時，後端**必須**將此操作翻譯為一個 **Git Commit**。
    *   後端服務應執行以下原子操作：
        1.  從內部 Git 倉庫 `clone` 或 `pull` 最新的腳本。
        2.  用新的「腳本內容」覆寫檔案。
        3.  執行 `git add` 和 `git commit`。**Commit Message 必須是結構化的**，例如 `Update script 'Auto-scaling for Web Servers' by user 'admin' via SRE Platform`。
        4.  執行 `git push` 將變更推回遠端倉庫。
        5.  更新 PostgreSQL 中 `scripts` 表的 `commit_hash` 欄位，使其指向這個新的 Commit。
2.  **參數定義的儲存**：
    *   腳本的參數定義（名稱、類型、預設值、是否必需）不應儲存在腳本檔案內，而應作為**元數據**，以 JSONB 格式儲存在 PostgreSQL 的 `scripts` 表的 `parameters_definition` 欄位中。這使得平台可以在不解析腳本內容的情況下，快速生成執行時的輸入表單。

**API 設計**：
*   `PUT /api/v1/scripts/{id}`：此 API 的請求體 (Payload) 應包含：
    *   `name`, `description` (基本資訊)。
    *   `content` (新的腳本內容)。
    *   `parameters_definition` (更新後的參數定義 JSON)。
    *   `commit_message` (可選，若為空，後端應自動生成)。
    *   後端處理此請求後，應回傳包含新 `commit_hash` 的完整腳本元數據。

**UX/UI 強化建議**：
1.  **引入 Web IDE (Monaco Editor)**：
    *   目前的「腳本內容」只是一個簡單的 `<textarea>`。**必須**將其替換為 **Monaco Editor** (VS Code 的核心引擎)。這將立即帶來企業級的體驗，包括：
        *   **精準的語法高亮** (Python, Bash, etc.)。
        *   **程式碼自動補全**。
        *   **語法錯誤即時提示 (Linting)**。
        *   **程式碼摺疊**和**小地圖導航**。
2.  **實現真正的版本控制 UI**：
    *   在彈窗中增加一個「**版本歷史 (Version History)**」分頁。
    *   此分頁應呼叫 `GET /api/v1/scripts/{id}/history` API 來獲取 Git 提交歷史。
    *   UI 上應以列表形式展示每一次 Commit，包含 `commit_hash`、作者、時間和 Commit Message。
    *   使用者可以點擊**任一 Commit** 查看當時的程式碼快照。
    *   使用者可以選中**任意兩個版本**，UI 應在一個**並排比較 (Side-by-Side Diff)** 視圖中清晰地展示其差異。
    *   每個歷史版本旁都應有一個「**還原到此版本 (Revert to this version)**」按鈕，讓 SRE 可以安全、快速地回滾錯誤的變更。
3.  **增強的參數設定**：
    *   參數類型不應僅限於 `String`。應擴充為一個更豐富的類型系統，至少包括 `String`, `Number`, `Boolean` (渲染為開關), 和 `Secret` (渲染為密碼輸入框，其值絕不應在 API 中明文傳輸，而應是一個指向 Vault 中祕密的引用)。
    *   應允許為參數設定「**預設值**」和「**是否必填**」的選項。

#### 編輯排程 - 簡易模式 [編輯排程-簡易模式](images/55-彈窗-排程管理-編輯排程-簡易模式.png)

**功能描述**：
- 排程任務編輯彈窗的簡易模式
- 提供常用的排程選項和快速設定
- 支援基本重複模式設定

**相關 API 端點**：
- `PUT /api/v1/schedules/{id}` - 更新排程任務

**UX 改善建議**：
1. **智能時間選擇**：提供視覺化時間選擇器和CRON表達式產生器
2. **即時預覽**：即時顯示下次執行時間和排程的人類可讀描述
3. **衝突檢查**：自動檢查與其他排程的時間衝突
4. **資源約束**：設定執行時間限制和資源使用限制
5. **依賴排程**：支援任務間的依賴關係和條件觸發

**Jules 的分析與建議**：

我已審閱此彈窗設計。簡易模式是降低自動化使用門檻、讓非專家也能安全設定排程的關鍵。其核心價值在於**將複雜的 CRON 語法，抽象化為人類可理解的、引導式的選項**。

**後端架構與設計**：
1.  **核心職責：翻譯層 (Translation Layer)**
    *   此 UI 的後端核心是一個**翻譯器**。它接收來自前端的、結構化的簡易排程物件，並將其可靠地轉換為標準的 CRON 表達式，然後儲存到資料庫的 `cron_expression` 欄位。
    *   **範例翻譯**：
        *   `{ "frequency": "daily", "time": "11:00" }` -> `0 11 * * *`
        *   `{ "frequency": "weekly", "day_of_week": 6, "time": "14:30" }` -> `30 14 * * 6`
        *   `{ "frequency": "monthly", "day_of_month": 1, "time": "01:00" }` -> `0 1 1 * *`
    *   這個翻譯邏輯必須有完整的單元測試覆蓋，以確保其準確性。
2.  **API 設計：統一入口，區分模式**
    *   `POST /api/v1/schedules` 和 `PUT /api/v1/schedules/{id}` 的請求體 (Payload) 應包含一個 `mode` 欄位 (`"simple"` 或 `"advanced"`)。
    *   如果 `mode` 是 `"simple"`，則 payload 應包含一個 `simple_schedule_data` 物件，其結構對應簡易模式的選項。後端在儲存前，會呼叫翻譯層將其轉換為 `cron_expression`。
    *   如果 `mode` 是 `"advanced"`，則 payload 直接包含 `cron_expression` 字串。

**UX/UI 強化建議**：
1.  **即時反饋與預覽 (Real-time Feedback & Preview)**：
    *   這是最重要的 UX 改善。當使用者在簡易模式下調整「執行頻率」或「執行時間」時，介面上**必須**有一個區域**即時顯示**對應的 CRON 表達式和**接下來 3 次的預計執行時間**。
    *   例如，當使用者選擇「每日」和「11:00」，UI 上應立即顯示：
        > 預覽: `0 11 * * *`
        >
        > 接下來的執行時間:
        > - 2025-09-19 11:00:00 (Asia/Taipei)
        > - 2025-09-20 11:00:00 (Asia/Taipei)
        > - 2025-09-21 11:00:00 (Asia/Taipei)
    *   這個即時預覽能給予使用者極大的信心，確保他們的設定被系統正確理解。
2.  **明確的時區處理**：
    *   「執行時間」輸入框旁應明確標示其所使用的**時區**（例如，顯示 `(UTC+8)` 或 `(Asia/Taipei)`）。
    *   理想情況下，應允許使用者為每個排程單獨選擇時區，以應對跨國團隊或跨時區資源的管理需求。
3.  **目標資源的智慧化**：
    *   「目標資源」的下拉選單應支援**搜尋**和**分組**（按資源群組或標籤）。對於有大量資源的環境，這是確保可用性的基本要求。
    *   選中資源後，應以標籤 (Tag) 的形式顯示，而不是一個擁擠的下拉選單。

#### 編輯排程 - 進階模式 [編輯排程-進階模式](images/56-彈窗-排程管理-編輯排程-進階模式.png)

**功能描述**：
- 排程任務編輯彈窗的進階模式
- 支援複雜的CRON表達式設定
- 提供日曆視圖和時間預測

**相關 API 端點**：
- `PUT /api/v1/schedules/{id}` - 更新排程任務

**UX 改善建議**：
1. **進階表達式**：支援複雜CRON表達式的視覺化編輯和驗證
2. **時間帶支援**：支援多時區的排程設定和轉換
3. **異常處理**：配置排程失敗時的重試策略和通知
4. **歷史分析**：分析排程的執行歷史和性能趨勢
5. **資源監控**：即時監控排程執行的資源使用情況

**Jules 的分析與建議**：

我已審閱此彈窗設計。進階模式賦予了 SRE 專家們最大的靈活性，讓他們可以定義任意複雜的排程。此模式的核心設計理念應是**在提供完全控制權的同時，給予足夠的輔助和驗證，防止因手誤引發的錯誤**。

**後端架構與設計**：
1.  **核心職責：驗證層 (Validation Layer)**
    *   在進階模式下，後端的主要職責是**驗證**。當接收到 `PUT /api/v1/schedules/{id}` 請求且 `mode` 為 `"advanced"` 時，後端**必須**使用一個可靠的 Go Cron 解析函式庫 (如 `robfig/cron`) 來驗證 `cron_expression` 字串的語法是否有效。
    *   如果語法無效，API **必須**回傳 `400 Bad Request` 狀態碼，並在回應主體中提供清晰的錯誤訊息，例如 `{"error": "Invalid CRON expression: field 'day of week' has value out of range"}`。
2.  **API 設計**：
    *   API 設計與簡易模式保持一致。當 `mode` 為 `"advanced"` 時，API 直接接收 `cron_expression` 字串，驗證後存入資料庫。
    *   無論是簡易模式還是進階模式，後端都應在儲存後，立即根據最終的 `cron_expression` 計算 `next_execution_time` 並更新資料庫欄位，確保資料的一致性。

**UX/UI 強化建議**：
1.  **即時 CRON 驗證與翻譯器**：
    *   這是此介面**最重要的 UX 強化**。絕不能讓使用者在點擊「儲存」後才發現 CRON 寫錯了。
    *   當使用者在「CRON 表達式」輸入框中打字時，UI 應**即時**提供以下三種反饋：
        1.  **語法檢查**：輸入框旁顯示一個圖示，有效時為綠色勾號 ✅，無效時為紅色叉號 ❌。
        2.  **語義翻譯**：在輸入框下方，將 CRON 表達式**即時翻譯成人類可讀的語言**。例如，輸入 `0 11 * * 1-5` 後，下方立即顯示「此任務將在每個工作日 (週一至週五) 的上午 11:00 執行」。
        3.  **執行預覽**：進一步顯示**接下來 5 次的預計執行時間**列表，並附上時區，讓使用者可以完全確認排程的行為是否符合預期。
2.  **內建 CRON 語法速查表**：
    *   點擊輸入框旁的資訊圖示 (`i`)，不應只是一個簡單的 Tooltip，而應彈出一個**包含常用範例的速查表 (Cheat Sheet)**。
    *   這個速查表應提供類似以下的內容，並允許使用者**點擊範例直接填入**輸入框：
        *   `* * * * *` - 每分鐘
        *   `0 */2 * * *` - 每兩小時
        *   `0 9-17 * * 1-5` - 每個工作日的 9 點到 17 點，每小時的 0 分
        *   `@daily` - 每日凌晨 0 點 (等同於 `0 0 * * *`)

透過這些強化，即使是進階模式，也能變得極為友好和高效，有效減少人為失誤，提升平台的整體可靠性。

#### 執行日誌詳情 [執行日誌詳情](images/57-彈窗-執行日誌-執行日誌詳情.png)

**功能描述**：
- 執行日誌詳情抽屜
- 顯示腳本執行的完整日誌和輸出
- 支援日誌搜尋和過濾功能

**相關 API 端點**：
- `GET /api/v1/execution-logs/{id}` - 獲取執行詳情
- `GET /api/v1/execution-logs/{id}/output` - 獲取執行輸出

**UX 改善建議**：
1. **功能完善**：根據具體功能需求提供相應的UX改善建議
2. **使用者體驗優化**：改善界面交互和操作流程
3. **可及性改善**：提升界面的可及性和易用性
4. **性能優化**：優化載入速度和響應時間
5. **錯誤處理**：完善錯誤提示和異常情況處理

### 排程管理 [排程管理](images/52-頁面-排程管理.png)

**功能描述**：
- 自動化任務排程管理
- 排程統計和執行狀態監控
- 排程表格：啟用狀態、任務名稱、腳本名稱、CRON 條件、上次狀態、上次執行時間、下次執行時間
- 排程狀態指示（SUCCESS/FAILED）

**相關 API 端點**：
- `GET /api/v1/schedules` - 獲取排程列表
- `POST /api/v1/schedules` - 創建新排程
- `PUT /api/v1/schedules/{id}` - 更新排程
- `DELETE /api/v1/schedules/{id}` - 刪除排程
- `PUT /api/v1/schedules/{id}/toggle` - 啟用/停用排程

**UX 改善建議**：
1. **視覺化排程**：提供日曆視圖顯示排程時間表
2. **CRON 助手**：可視化 CRON 表達式生成器
3. **執行預測**：顯示未來執行時間預測
4. **依賴排程**：支援任務間的依賴關係設定
5. **告警整合**：排程失敗時自動發送告警

**Jules 的分析與建議**：

我已審閱此頁面設計。排程管理是自動化中心的大腦，負責在無人干預的情況下，可靠、準時地觸發例行任務。此 UI 設計清晰地展示了排程的核心資訊，但其背後的後端架構是確保功能成敗的關鍵。

**後端架構與設計**：
1.  **核心引擎：持久化排程器 (Persistent Scheduler)**
    *   後端**必須**採用一個支援**持久化**的 Go Cron 函式庫（如 `gocron` 搭配其 `postgres-adapter`）。這意味著即使後端服務重啟，已註冊的排程任務也不會遺失。
    *   平台啟動時，排程器服務會從 `schedules` 資料表中載入所有「已啟用」的排程，並在記憶體中註冊對應的 Cron Job。
2.  **資料庫模型 (`schedules` table)**：
    *   核心欄位應包含：`id`, `name`, `script_id` (關聯到腳本), `cron_expression`, `is_enabled`, `parameters` (JSONB，儲存腳本執行時所需的參數), `last_execution_time`, `next_execution_time`, `last_status` (`SUCCESS`, `FAILED`)。
    *   `next_execution_time` **必須**由後端排程器在每次任務執行完畢或更新排程後，根據 CRON 表達式**重新計算並寫回資料庫**。前端應直接讀取此欄位，而不是自行計算。
3.  **排程觸發工作流程**：
    *   當一個 Cron Job 被觸發時，排程器**不應直接執行**腳本。
    *   正確流程是：排程器將一個「執行任務」（包含 `script_id` 和 `parameters`）推送到與腳本庫共用的**非同步任務佇列**中。
    *   任務執行器 (Worker) 消費此任務，執行腳本，並在執行結束後，將結果（成功/失敗）和日誌 ID **回寫**到 `execution_logs` 表。同時，應有一個回呼 (callback) 機制來更新 `schedules` 表中對應任務的 `last_status` 和 `last_execution_time`。

**API 設計**：
*   `GET /api/v1/schedules`：回傳排程列表。此 API 應直接從 `schedules` 表中讀取資料，包含後端已計算好的 `last_status` 和 `next_execution_time`。
*   `POST /api/v1/schedules`：建立新排程。後端在寫入資料庫的同時，必須向執行中的排程器服務**動態註冊**這個新的 Cron Job。
*   `PUT /api/v1/schedules/{id}`：更新排程。後端需要先從排程器中移除舊的 Job，更新資料庫，然後再註冊一個新的 Job。
*   `PUT /api/v1/schedules/{id}/toggle`：切換啟用狀態。後端根據 `is_enabled` 的值，向排程器服務動態新增或移除對應的 Cron Job。

**UX/UI 強化建議**：
1.  **CRON 表達式的人性化**：
    *   在「CRON 條件」欄位（如 `每日 2:00`）旁，應增加一個資訊圖示 (`i`)。滑鼠懸停時，顯示一個工具提示 (Tooltip)，將 CRON 表達式**翻譯成人類可讀的語言**（例如，「此任務將在每個月的1號和15號的凌晨3點執行」）。可以使用 `cron-parser` 或類似函式庫在前端或後端實現。
2.  **即時測試與反饋**：
    *   在操作欄中，除了「編輯」和「刪除」，應增加一個「**立即執行 (Run Now)**」的按鈕。這允許使用者在不等待排程時間的情況下，立即觸發一次任務，以測試其正確性。
3.  **無縫的日誌追蹤**：
    *   「上次狀態」欄位中的 `SUCCESS`/`FAILED` 標籤應是一個**超連結**，直接鏈接到**該次執行的詳細日誌頁面**。這能讓使用者在排程失敗時，一鍵跳轉到日誌進行問題排查，形成高效的工作閉環。
4.  **避免排程漂移 (Schedule Drift)**：
    *   UI 應清楚地顯示每個時間戳的**時區**（例如，`Asia/Taipei`），並在排程編輯頁面中允許使用者為排程指定時區，以避免因夏令時或伺服器時區不同而導致的執行時間漂移問題。

### 執行日誌 [執行日誌](images/53-頁面-執行日誌.png)

**功能描述**：
- 自動化腳本執行歷史記錄
- 執行日誌檢索和篩選（時間範圍、腳本名稱篩選）
- 日誌表格：狀態、腳本名稱、觸發方式、開始時間、執行結果
- 執行狀態分類（SUCCESS/FAILED）

**相關 API 端點**：
- `GET /api/v1/execution-logs` - 獲取執行日誌
- `GET /api/v1/execution-logs/{id}` - 獲取詳細執行日誌
- `GET /api/v1/execution-logs/{id}/output` - 獲取執行輸出

**UX 改善建議**：
1. **實時日誌**：執行過程中的實時日誌流
2. **日誌分析**：錯誤模式分析和智能建議
3. **性能統計**：執行時間趨勢和性能分析
4. **日誌導出**：支援日誌導出和長期歸檔
5. **告警關聯**：關聯執行失敗與系統告警

**Jules 的分析與建議**：

我已審閱此頁面設計。執行日誌是自動化系統的「飛行紀錄儀」，不僅是排查問題的依據，也是衡量自動化有效性和安全性的關鍵。此 UI 提供了基本的列表和篩選，但要將其打造成一個強大的偵錯與審計工具，必須採用正確的後端技術並極大化其查詢能力。

**後端架構與設計**：
1.  **日誌儲存：Elasticsearch 為核心**
    *   根據 `architecture.md`，所有日誌資料（包括此處的執行日誌）的**單一事實來源 (SSOT)** 應為 **Elasticsearch**。
    *   **嚴禁**將日誌的完整輸出 (stdout/stderr) 儲存在 PostgreSQL 中，這會導致資料庫膨脹、查詢效能低下，且無法實現全文檢索。
2.  **資料模型 (Elasticsearch Index)**：
    *   應為執行日誌建立一個專門的 Elasticsearch 索引 (e.g., `execution-logs-YYYY.MM`)。
    *   每個日誌文件 (Document) 都應是結構化的，包含以下關鍵欄位：
        *   `execution_id` (keyword): 唯一執行 ID。
        *   `script_id` (keyword): 關聯的腳本 ID。
        *   `script_name` (keyword): 腳本名稱。
        *   `trigger_type` (keyword): 觸發方式 (`EVENT`, `SCHEDULE`, `MANUAL`)。
        *   `trigger_by` (keyword): 觸發者 (使用者 ID 或 `system`)。
        *   `status` (keyword): `SUCCESS`, `FAILED`, `RUNNING`。
        *   `start_time`, `end_time` (date): 起止時間。
        *   `duration_ms` (long): 執行耗時（毫秒）。
        *   `output` (text): **完整的 stdout/stderr 輸出**，這是實現全文檢索的關鍵。
        *   `parameters` (object): 執行的輸入參數。
3.  **日誌收集流程**：
    *   任務執行器 (Worker) 在執行腳本時，應透過一個日誌函式庫 (如 Zap) 將日誌**直接、即時地**串流到 Elasticsearch，而不是在任務結束後才整批寫入。這使得使用者可以即時查看正在執行中的任務日誌。

**API 設計**：
*   `GET /api/v1/execution-logs`：此 API 的後端實現**必須**是查詢 **Elasticsearch**，而非 PostgreSQL。
    *   **篩選**: API 應支援基於 `script_name`, `status`, `trigger_type` 和時間範圍 (`@timestamp`) 的精確篩選。
    *   **全文檢索**: 圖片中的「搜尋腳本名稱或觸發者」搜尋框，其後端查詢應使用 Elasticsearch 的 `multi_match` 查詢，同時搜尋 `script_name`, `trigger_by` 和 **`output`** 欄位。這允許使用者輸入「`Error: connection refused`」來快速找到所有包含此錯誤訊息的執行記錄。
*   `GET /api/v1/execution-logs/{id}`：獲取單一執行記錄的**完整**日誌輸出，同樣來自 Elasticsearch。

**UX/UI 強化建議**：
1.  **強化的日誌檢視器**：
    *   點擊任一列表項目，應在一個**抽屜 (Drawer) 或彈窗 (Modal)** 中開啟一個功能豐富的日誌檢視器。
    *   此檢視器必須提供**語法高亮**（若日誌內容為 JSON 或 YAML）、**顯示行號**和**一鍵複製完整日誌**的功能。
    *   對於長日誌，應提供**即時搜尋和高亮**匹配關鍵字的功能。
2.  **上下文的無縫追溯**：
    *   表格中的「觸發方式」欄位應是**可點擊的超連結**。例如：
        *   若為 `Event`，點擊後應彈出關聯事件的詳情。
        *   若為 `Schedule`，點擊後應跳轉到該排程的設定頁面。
        *   若為 `Manual (admin)`，點擊後應顯示該使用者的資訊。
    *   「腳本名稱」也應直接連結到該腳本的編輯頁面。
3.  **智慧化快速篩選器**：
    *   除了時間和關鍵字，應在搜尋框旁提供一組**預設的快速篩選按鈕**，如：「**僅顯示失敗的**」、「**過去 1 小時內**」、「**由我觸發的**」。這能極大提升日常排錯效率。

---

## 6.設定-身份與存取管理


### 身份與存取管理

#### 人員管理 [人員管理](images/60-頁面-人員管理.png)

**功能描述**：
- 作為 Keycloak 的代理，提供一個管理平台內部角色與團隊映射的介面。
- 顯示從 Keycloak 同步的人員列表，並附加其在本平台內的權限設定。
- 提供邀請新人員、管理平台內狀態、以及分配團隊和角色的功能。
- KPI 面板顯示從 Keycloak 獲取的統計數據，如總人數、在線人數和待處理邀請。

**Jules 的分析與建議**：

我已審閱此頁面與其編輯彈窗 (`images/65-彈窗-人員管理-編輯人員.png`)。根據 `docs/architecture.md` 的規定，身份管理已完全委託給 Keycloak。因此，此功能的設計必須從「人員管理系統」轉變為「**Keycloak 代理與權限映射介面**」。目前的 UI 和 API 設計與此架構存在衝突，需進行以下深度重構：

**核心原則：職責分離**
- **Keycloak (SSO Provider)**：唯一負責人員的生命週期（建立、刪除）、基本資料（姓名、Email）、憑證管理和帳號狀態（啟用/停用）。
- **SRE 平台**：唯一負責將 Keycloak 使用者映射到平台內部的**團隊 (Teams)** 和**角色 (Roles)**。

**API 重構 (代理 Keycloak)**
1.  **`GET /api/v1/users`**：此 API 應作為 Keycloak `GET /admin/realms/{realm}/users` 的代理。後端從 Keycloak 獲取使用者列表後，應使用本地資料庫的資訊來**豐富 (enrich)** 每個使用者物件，附加其 `teams` 和 `roles` 資訊。
2.  **廢棄 `POST /api/v1/users`**：直接在平台建立使用者的功能應被移除。取而代之的是一個**邀請流程**：
    *   **`POST /api/v1/invitations`**：接收 `email`, `first_name`, `last_name`。後端呼叫 Keycloak Admin API 建立一個新使用者，並觸發 Keycloak 的 `execute-actions-email` 流程，向使用者發送設定密碼的邀請郵件。
3.  **重構 `PUT /api/v1/users/{id}`**：此 API 的權限必須被嚴格限制。它**只能**更新平台資料庫中的 `team_ids` 和 `role_ids` 映射關係。任何修改 `name` 或 `email` 的嘗試都應被拒絕。
4.  **釐清 `PUT /api/v1/users/{id}/toggle` 的職責**：
    *   UI 上的「啟用」開關不能直接操作 Keycloak 的 `enabled` 狀態。這違反了職責分離原則。
    *   此 API 應更名為 **`PUT /api/v1/users/{id}/internal-status`**，它僅更新平台資料庫中 `users` 表的 `is_active` 欄位。此欄位用於控制平台內部的業務邏輯（如是否可被指派任務），而非登入權限。
5.  **廢棄 `DELETE /api/v1/users/{id}`**：應改為**軟刪除 (Soft Delete)**。此操作僅在平台資料庫中設定 `deleted_at` 時間戳，以保證歷史資料的完整性。可選擇性地在 Keycloak 中將使用者設為非活躍狀態，但不應直接刪除。

**UX/UI 重構**
1.  **「新增人員」改為「邀請人員」**：主頁面上的「+ 新增人員」按鈕應改為「**邀請人員**」。彈出的對話框只應包含 Email、姓、名等最基本資訊，不應包含密碼欄位。
2.  **使用者資訊唯讀**：在「人員列表」和「編輯人員」彈窗中，**姓名**和**電子郵件**欄位必須是**唯讀**的，並明確標示其資料來源為 SSO 系統。
3.  **重新定義「啟用」開關**：
    *   表格中的「啟用」開關應改名為「**平台內啟用**」。
    *   必須為此開關提供一個工具提示 (Tooltip)，解釋其作用：「**停用後，此使用者將無法被指派任務或接收通知，但其 SSO 帳號不受影響，仍可登入平台。**」
4.  **簡化「編輯人員」彈窗**：此彈窗 (`images/65...`) 的核心價值在於「**權限設定**」。應將唯讀的「基本資訊」放在頂部，並將視覺焦點和主要互動區域集中在「所屬團隊」和「角色」的分配上。

#### 編輯人員 [編輯人員](images/65-彈窗-人員管理-編輯人員.png)

**功能描述**：
- 修改人員在平台內部的權限設定。
- 顯示從 Keycloak 同步的唯讀基本資訊（姓名、Email）。
- 提供介面來管理使用者所屬的團隊和分配的角色。

**相關 API 端點**：
- `PUT /api/v1/users/{id}` - **（已重構）** 僅更新使用者在平台內部的團隊和角色映射。

**UX 改善建議**：
1. **聚焦核心功能**：將介面焦點完全集中在團隊和角色的選擇上，弱化唯讀的使用者基本資訊。
2. **權限預覽**：在儲存前，可以預覽變更後的權限組合將帶來哪些具體的權限變化。
3. **批次指派**：在人員管理主列表上，應支援批次將多位使用者新增至同一個團隊或指派同一個角色。
4. **清晰的資料來源標示**：在姓名和 Email 欄位旁，可增加一個小的資訊圖示，提示使用者「此資訊由身份提供商管理」。




#### 設定頁面 [設定頁面](images/64-頁面-設定.png)

**功能描述**：
- 作為所有管理功能的統一入口頁面 (Launchpad)。
- 使用卡片式設計，將各項設定功能邏輯地分組，如「身份與存取管理」、「通知管理」和「平台設定」。
- 為管理者提供清晰的導航，快速進入特定的設定模組。

**Jules 的分析與建議**：

此設定頁面的設計清晰、直觀，作為一個「控制台總覽」非常有效。我的建議將專注於如何讓這個靜態的導航頁面變得更**智慧**、更**動態**。

**核心原則：情境感知與資訊密度 (Context-Aware & Information-Dense)**
- 此頁面不僅應是連結的集合，更應提供一個關於平台健康度和設定狀態的微型儀表板。

**API 設計**
1.  **整合的統計 API**：為了讓頁面動態化，後端應提供一個單一的、高效能的統計 API 端點。此端點應回傳所有卡片可能需要的計數，且其後端實現應大量依賴**快取**，以確保頁面能瞬時載入。
    *   **`GET /api/v1/settings/statistics`**
        ```json
        {
          "iam": { "user_count": 156, "team_count": 12, "role_count": 8 },
          "notifications": { "policy_count": 25, "channel_count": 5 },
          "platform": { "tag_count": 50 }
        }
        ```

**UX/UI 強化**
1.  **基於角色的可見性 (Role-Based Visibility)**：這是最重要的安全與體驗強化。使用者在此頁面上看到的卡片，應嚴格**基於其自身角色所擁有的權限**。例如，一個沒有「平台設定」管理權限的角色，登入後根本不應看到「平台設定」那一區塊的所有卡片。這可以在前端根據登入時獲取的權限列表，動態渲染卡片來實現。
2.  **動態副標題 (Dynamic Subtitles)**：將卡片上靜態的描述文字，替換為動態的、包含關鍵指標的副標題。
    *   「人員管理」卡片的副標題可以從「管理使用者帳號與權限」變為「**156** 位使用者 · **8** 個角色」。
    *   「通知策略」卡片的副標題可以變為「**25** 條策略 · **5** 個通知管道」。
    這將使頁面一目了然，極大提升資訊密度。
3.  **「新功能」提示徽章**：當某個設定模組增加了重要新功能時（例如，「角色管理」增加了「複製角色」功能），可以在對應的卡片右上角增加一個小小的「**新**」字徽章。這是一種非常有效的、非侵入式的方式，用以引導使用者發現產品的改進。

#### 團隊管理 [團隊管理](images/61-頁面-團隊管理.png)

**功能描述**：
- 管理平台內部的團隊，這些團隊是問責制和通訊的核心單位。
- 每個團隊由一組核心成員、一個負責人以及一組可選的訂閱者組成。
- 此介面用於建立團隊、管理其成員，並作為檢視團隊職責（如負責的資源、關聯的通知）的入口。

**Jules 的分析與建議**：

我已審閱此頁面與其編輯彈窗 (`images/66-彈窗-團隊管理-編輯團隊.png`)。根據 `docs/architecture.md` 中的「權責分離原則」，「團隊」是連接**使用者**、**資源**和**通知**的關鍵樞紐。此功能的設計應強化其作為「問責中心」的角色，而不僅僅是使用者分組。

**核心原則：團隊即問責 (Team as Accountability)**
- 團隊是平台內資源（透過「資源群組」）和警報（透過「通知策略」）的指定接收者。
- 團隊應具備明確的「負責人」，以及「成員」和「訂閱者」兩種不同層級的參與者。

**API 設計與資料模型**
1.  **`teams` 資料模型**：後端 `teams` 表應包含 `name`, `description`, `leader_id` (外鍵關聯至 `users`)。
2.  **成員 vs. 訂閱者**：
    *   **成員 (Members)**：透過 `user_teams` 多對多關聯表進行管理。他們是團隊的核心執行者。
    *   **訂閱者 (Subscribers)**：一個非常有價值的概念。應透過獨立的 `team_subscribers` 多對多關聯表來管理。訂閱者可以是平台內的使用者，甚至是外部郵件地址，他們僅接收通知，不參與直接操作。
3.  **API 端點**：
    *   `GET /api/v1/teams`：回傳的團隊列表物件中，應包含 `leader` 的詳細資訊以及 `member_count` 和 `subscriber_count`。
    *   `GET /api/v1/teams/{id}`：除了團隊基本資訊，還應回傳完整的 `members` 和 `subscribers` 列表。
    *   `PUT /api/v1/teams/{id}`：請求體應允許同時更新團隊的基本資料（`name`, `leader_id`）和完整的 `member_ids` 列表。後端應負責計算差異並更新 `user_teams` 關聯表。
    *   **`GET /api/v1/teams/{id}/responsibilities`** (建議新增)：一個新的唯讀端點，用於回傳與該團隊關聯的所有物件，如 `resource_groups` 和 `notification_policies`，為團隊詳情頁提供資料。

**UX/UI 強化**
1.  **從「列表」到「儀表板」**：目前頁面是一個簡單的列表。長遠來看，應考慮將其升級為「團隊儀表板」。點擊一個團隊應進入一個**專屬的團隊詳情頁**，該頁面聚合顯示：
    *   團隊成員、負責人、訂閱者。
    *   **團隊負責的資源群組**列表。
    *   **關聯的通知策略**和靜音規則。
    *   （進階）與 Grafana OnCall 整合的**目前值班表**。
    這將極大地提升此功能在日常維運中的實用性。
2.  **釐清「成員」與「訂閱者」**：在主列表的欄位標題上，為「成員數」和「訂閱者數」增加工具提示，解釋其區別：「**成員**：負責此團隊資源的工程師。**訂閱者**：僅接收此團隊相關通知的利害關係人。」
3.  **優化編輯彈窗**：
    *   編輯彈窗 (`images/66...`) 中的「負責人」欄位應是一個可搜尋的使用者選擇器。
    *   用於新增成員的雙欄選擇器（Transfer 元件）是有效的。為提升效率，左側的「可用人員」列表應支援搜尋和篩選功能。

#### 編輯團隊 [編輯團隊](images/66-彈窗-團隊管理-編輯團隊.png)

**功能描述**：
- 修改團隊的基本資訊（名稱、描述、負責人）。
- 透過雙欄選擇器管理團隊的核心成員。

**相關 API 端點**：
- `PUT /api/v1/teams/{id}` - 更新團隊資訊，包括其成員列表。

**UX 改善建議**：
1. **成員搜尋**：在「可用人員」列表中增加搜尋框，以便在大量使用者中快速找到目標成員。
2. **職責預覽**：在彈窗中（可能是一個獨立的頁籤），可以預覽此團隊目前負責的資源群組和關聯的通知策略，讓管理者在調整成員時能了解其影響範圍。
3. **負責人指派**：負責人應從團隊的現有成員中選擇，或在選擇後自動加入成為成員。

#### 角色管理 [角色管理](images/62-頁面-角色管理.png)

**功能描述**：
- 集中管理平台的所有角色 (Role) 及其對應的權限 (Permissions)。
- 提供清晰的介面來建立、檢視、編輯和刪除自訂角色。
- 以樹狀結構展示所有可用的權限，並按功能模組進行分組，方便管理者進行權限分配。

**Jules 的分析與建議**：

我已審閱此頁面與其新增彈窗 (`images/67-彈窗-角色管理-新增角色.png`)。這是一個設計得非常出色的 RBAC (Role-Based Access Control) 管理介面，直觀且遵循了業界的最佳實踐。我的分析將專注於強化其後端實現的**穩健性**和**可維護性**，並提出進一步提升使用者體驗的建議。

**核心原則：權限即程式碼 (Permissions as Code)**
- 角色是權限的集合，而權限本身應該是明確且穩定的。

**API 設計與後端架構**
1.  **權限的單一事實來源 (SSOT)**：所有平台內可用的權限，其定義的**唯一真實來源 (Single Source of Truth)** 應該是**後端程式碼**中的一個靜態設定檔或列舉。這確保了權限是版本可控的，且不會在資料庫中產生無效或廢棄的權限資料。
    *   **`GET /api/v1/permissions`**：後端應提供此端點，回傳在程式碼中定義好的、結構化的完整權限樹，供前端 UI 動態建構權限勾選框。
2.  **資料庫模型**：
    *   `roles` 表：包含 `id`, `name`, `description`, `is_built_in` (布林值，用於標識不可刪除的內建角色)。
    *   `role_permissions` 關聯表：僅包含 `role_id` 和 `permission_key` (字串)，用於儲存角色與權限碼的對應關係。
3.  **API 端點**：
    *   `POST /api/v1/roles`：建立新角色。請求體應包含 `name`, `description` 和一個**權限碼的陣列** (`permission_keys`)。
    *   `PUT /api/v1/roles/{id}`：更新角色。後端應嚴格禁止修改 `is_built_in` 為 `true` 的角色。
    *   `DELETE /api/v1/roles/{id}`：刪除角色。在刪除前，後端必須檢查此角色是否已指派給任何使用者。如果已指派，應回傳錯誤並提示管理者先解除所有使用者的指派。

**UX/UI 強化**
1.  **權限說明 (Permission Descriptions)**：在權限樹的每個勾選框旁，增加一個**說明圖示 (i)**。滑鼠懸停時，顯示此權限的詳細解釋。例如，「寫入事件規則」的說明可能是「允許使用者建立新規則、修改現有規則的觸發條件、內容與自動化設定」。這能消除歧義，幫助管理者做出更精準的授權。
2.  **角色使用計數器 (Role Usage Counter)**：在左側的角色列表 (`images/62...`) 中，為每個角色名稱旁增加一個**徽章 (Badge)**，顯示目前有多少使用者被指派了此角色。這對於評估修改或刪除一個角色所帶來的影響至關重要。點擊此徽章可彈出一個對話框，顯示所有被指派此角色的使用者列表。
3.  **複製角色 (Clone Role) 功能**：在角色列表上方，新增一個「**複製角色**」的按鈕。這是一個巨大的效率提升功能。當管理者選擇一個現有角色（如「團隊管理員」）並點擊「複製」時，系統會打開「新增角色」彈窗，並預先填入所有資訊（角色名稱為「團隊管理員 (副本)」，並勾選所有相同的權限），讓管理者可以快速微調並建立一個新角色。
4.  **整合審計日誌**：所有對角色的操作（建立、更新、刪除）都必須產生一條詳細的**審計日誌**。日誌應清楚記錄操作前後的權限變化，以便於安全審計和追溯。

#### 新增角色 [新增角色](images/67-彈窗-角色管理-新增角色.png)

**功能描述**：
- 提供表單來定義新角色的名稱。
- 透過樹狀勾選框來為新角色指派一組權限。

**相關 API 端點**：
- `POST /api/v1/roles` - 請求體包含角色名稱和一組權限碼。

**UX 改善建議**：
1. **權限搜尋**：當權限數量非常多時，在權限樹上方增加一個搜尋框，讓管理者可以快速篩選和定位特定的權限。
2. **範本化**：提供幾個預設的「角色範本」（如唯讀使用者、操作者），使用者選擇範本後，系統會自動勾選一組建議的權限，使用者可在此基礎上進行修改。

#### 審計日誌 [審計日誌](images/63-頁面-審計日誌.png)

**功能描述**：
- 作為平台不可變的「黑盒子」，記錄所有由使用者或系統執行的狀態變更操作。
- 提供強大的搜尋與篩選功能，以便進行安全審計、故障排除和合規性檢查。
- 顯示結構化的日誌列表，並能鑽取查看單次操作的完整上下文與變更內容。

**Jules 的分析與建議**：

我已審閱此頁面與其日誌詳情抽屜 (`images/68-抽屜-審計日誌-日誌詳情.png`)。審計日誌是企業級平台的基石，其核心價值在於**完整性、不可變性與可搜尋性**。目前的 UI 提供了良好的基礎，但其後端架構和詳情展示的深度需要大幅強化。

**核心原則：鉅細靡遺，無一遺漏 (Log Everything)**
- 任何透過 API 進行的寫入型操作 (CREATE, UPDATE, DELETE) 都必須產生一條對應的審計日誌。

**後端架構與資料模型 (以 Elasticsearch 為核心)**
1.  **資料流**：所有後端服務在執行寫入操作後，應將結構化的審計事件發布到一個**專用的訊息佇列 (如 Kafka)**。一個獨立的日誌服務會消費這些事件，並將其寫入 **Elasticsearch** 索引中。此非同步架構確保了業務服務的低延遲和日誌系統的高可靠性。
2.  **豐富的日誌結構**：儲存在 Elasticsearch 中的每一份文件都必須是高度結構化的，以便於進行複雜查詢。其結構應至少包含：
    ```json
    {
      "timestamp": "...",
      "actor": { "type": "user", "id": "...", "name": "...", "ip_address": "..." },
      "action": "UPDATE",
      "result": "SUCCESS",
      "resource": { "type": "AlertRule", "id": "...", "name": "..." },
      "change_context": { "reason": "...", "trace_id": "..." },
      "diff": {
        "old": { "threshold": "80" },
        "new": { "threshold": "85" }
      }
    }
    ```
3.  **API 設計**：
    *   `GET /api/v1/audit-logs`：此 API 的後端實現**必須**是將前端傳來的篩選條件（時間範圍、使用者、動作類型、關鍵字）轉換為一個 **Elasticsearch 的查詢 DSL**，而非查詢傳統資料庫。
    *   `GET /api/v1/audit-logs/{id}`：直接從 Elasticsearch 中依據文件 ID 獲取單條日誌的完整內容。

**UX/UI 強化**
1.  **展示「變更了什麼」**：這是最重要的改進。詳情抽屜 (`images/68...`) 目前的資訊不足。當使用者點擊一條 `UPDATE` 類型的日誌時，抽屜內**必須**渲染一個**視覺化的差異對比 (Diff Viewer)**，清楚地以紅綠高亮標示出欄位修改前和修改後的值。對於 `CREATE` 或 `DELETE` 操作，則應顯示該資源被建立或刪除時的完整資料快照。
2.  **賦予搜尋框強大能力**：頁面頂部的搜尋框不應只搜尋使用者，而應成為一個**全局搜尋框**。利用 Elasticsearch 的能力，它應能對日誌中的任何欄位進行全文檢索，包括使用者名稱、資源名稱、IP 位址，甚至是 `diff` 內容中的值。
3.  **萬物皆可連結**：
    *   在日誌表格中，「操作者」和「資源名稱」欄位都應該是**可點擊的超連結**，分別導向該使用者的管理頁面和該資源的詳情頁。
    *   反之，在每個資源的管理頁面（如某個特定的事件規則），都應提供一個「**檢視歷史紀錄**」的按鈕，點擊後直接跳轉到審計日誌頁面，並自動篩選出該資源的所有相關變更紀錄。這提供了關鍵的**上下文鑽取 (Contextual Drill-Down)** 能力。
4.  **匯出功能優化**：匯出功能應支援將目前的篩選結果匯出為 CSV 或 JSON 格式，以便於離線分析和歸檔。

#### 日誌詳情 [日誌詳情](images/68-抽屜-審計日誌-日誌詳情.png)

**功能描述**：
- 以抽屜形式顯示單條審計日誌的摘要資訊。
- 包含操作時間、操作者、動作、資源、結果和失敗訊息。

**相關 API 端點**：
- `GET /api/v1/audit-logs/{id}` - 獲取單條日誌的完整資料，特別是 `diff` 部分。

**UX 改善建議**：
1. **差異視覺化**：對於 `UPDATE` 操作，必須以並排或行內高亮的方式，清晰地展示修改前後的資料差異。
2. **完整資料快照**：對於 `CREATE` 和 `DELETE` 操作，應顯示資源被建立或刪除時的完整 JSON 資料。
3. **上下文連結**：提供快速連結到操作者和被操作資源的詳情頁面。
4. **複製 Trace ID**：提供一個按鈕，讓使用者可以一鍵複製與此次操作關聯的 OpenTelemetry Trace ID，以便在監控系統中進行深度追蹤。

## 7.設定-通知管理

### 通知管理

#### 通知策略 [通知策略](images/70-頁面-通知策略.png)

**功能描述**：
- 通知規則配置管理
- 通知統計和發送狀態
- 通知策略表格：策略名稱、觸發條件、通知管道、接收對象、狀態
- 策略測試和預覽功能

**相關 API 端點**：
- `GET /api/v1/notification-policies` - 獲取通知策略列表
- `POST /api/v1/notification-policies` - 創建通知策略
- `PUT /api/v1/notification-policies/{id}` - 更新通知策略
- `DELETE /api/v1/notification-policies/{id}` - 刪除通知策略

**UX 改善建議**：
1. **策略模擬**：提供策略觸發條件模擬測試
2. **通知預覽**：顯示通知內容預覽
3. **策略優化**：分析和優化通知策略效果
4. **多管道整合**：支援多種通知管道的整合配置
5. **智慧路由**：基於接收者偏好和可用性的智慧路由

**Jules 的分析與建議**：

我已審閱此頁面設計。此頁面是 SRE 平台作為 **Grafana 智慧型抽象層** 的絕佳範例。它成功地將 Grafana 功能強大但極其複雜、基於標籤的樹狀路由結構，轉化為一個扁平化、易於理解且更符合人類心智模型的策略列表。

**後端架構與 API 設計 (Grafana 代理模式)**：
1.  **核心職責 - 翻譯層**：本平台後端的核心職責是作為一個**雙向翻譯器**。
    *   **讀取 (`GET`)**: 後端呼叫 Grafana 的 `GET /api/v1/provisioning/policies` 端點，獲取其完整的、巢狀的路由樹 JSON。然後，它必須**解析**這棵樹，將每一條路由及其子路由「扁平化」為使用者在 UI 上看到的一行行策略。
    *   **寫入 (`POST`/`PUT`)**: 當使用者建立或更新一條策略時，後端接收到的是一個簡化的、扁平的策略物件。它必須根據此物件，**重新建構**出 Grafana 所要求的完整路由樹 JSON，然後再透過 `PUT /api/v1/provisioning/policies` 進行全量更新。
2.  **API 設計**：
    *   `GET /api/v1/notification-policies`：此 API 回傳的是後端經過翻譯和扁平化處理後的策略列表，而非 Grafana 的原始結構。
    *   `GET /api/v1/notification-policies/statistics`：頂部的 KPI 指標（如「今日通知量」、「送達率」）**必須**由一個背景作業，透過分析平台自身的 `notification_history` 表來**預先計算並快取**在 Redis 中，以確保頁面能快速載入。
3.  **「管道健康概覽」的實現**：此面板的數據同樣需要由背景作業定期（例如每 5 分鐘）更新。該作業會遍歷所有已設定的通知管道，呼叫其「發送測試」API，並將成功率和最後測試時間等結果儲存起來，供前端查詢。

**UX/UI 強化建議**：
1.  **策略的視覺化引導**：
    *   「新增通知策略」按鈕應啟動一個**多步驟的精靈 (Wizard)**（如圖片 `73, 74, 75` 所示），引導使用者完成「定義觸發條件」->「選擇通知管道」->「設定進階選項」的流程。這極大地降低了學習曲線。
2.  **上下文操作與測試**：
    *   在每一行的「操作」欄中，應提供一個「**發送測試告警**」的按鈕。點擊後，允許使用者選擇一個嚴重等級（如 `Critical`），後端則會模擬一個符合該策略觸發條件的告警，並將其發送到指定的通知管道。這為驗證策略的端到端正確性提供了極大的便利。
3.  **策略的「靜音」與「覆寫」**：
    *   每一行策略旁應提供一個「**臨時靜音**」的選項，允許使用者快速地（例如，在接下來的 1 小時內）暫停某條策略，而無需禁用整個規則。
    *   應清晰地向使用者展示策略的**執行順序**（通常是從上到下匹配），並解釋「停止匹配 (Stop matching)」的概念，讓高階使用者可以構建更複雜的路由邏輯。

#### 編輯通知策略1 [編輯通知策略1](images/73-彈窗-通知策略-編輯通知策略1.png)

**功能描述**：
- 通知策略編輯彈窗的第一步
- 設定基本資訊和觸發條件
- **智慧輸入功能**：根據匹配條件的類型自動選擇最適合的輸入方式
- 支援策略名稱、描述和條件配置

**相關 API 端點**：
- `PUT /api/v1/notification-policies/{id}` - 更新通知策略

**智慧輸入功能實現**：

##### 🎯 設計原則
- **適配性**：根據數據特點選擇輸入方式
- **一致性**：統一的UI風格和操作邏輯
- **靈活性**：支援單選、多選、自動完成等多種模式
- **容錯性**：防止輸入錯誤，提高配置準確性

##### 📋 輸入方式分類

| 輸入方式 | 適用場景 | 優點 | 適用標籤 |
|---------|---------|------|----------|
| **下拉選單** | 有限固定值 | 準確、快速、防錯 | severity, env, team, component, category |
| **自動完成** | 大量動態值 | 便捷、靈活、提示 | instance, service |
| **自由輸入** | 自定義匹配 | 靈活、通用 | alert_name, 其他 |

##### 🔧 實現細節

**智慧輸入函數**：
```javascript
const getSmartValueInput = (condition, index) => {
  const { key, value, operator } = condition;

  // 檢查是否為多選運算子
  const isMultiSelectOperator = operator === 'in' || operator === 'not_in';

  // 根據標籤類型選擇輸入方式
  switch (key) {
    case 'severity':
    case 'env':
    case 'team':
    case 'component':
    case 'category':
      return isMultiSelectOperator ?
        <MultiSelectDropdown /> :
        <SingleSelectDropdown />;

    case 'instance':
    case 'service':
      return <AutoCompleteInput />;

    default:
      return <FreeTextInput />;
  }
};
```

**多選運算子支援**：
```javascript
const operators = [
  { value: '=', label: '=' },
  { value: '!=', label: '!=' },
  { value: '~', label: '~' },
  { value: '!~', label: '!~' },
  { value: 'in', label: 'in' },      // 新增
  { value: 'not_in', label: 'not_in' } // 新增
];
```

##### 🎨 UI/UX 設計特點
- **顏色編碼**: severity 使用不同顏色標籤
- **圖標提示**: 不同輸入類型使用對應圖標
- **狀態指示**: 顯示當前選擇的值
- **鍵盤導航**: 支援上下鍵和 Enter 選擇
- **自動過濾**: 輸入時實時過濾選項

##### 📊 使用示例
- **severity + `=`**: 單選下拉選單（帶顏色標籤）
- **severity + `in`**: 多選下拉選單
- **instance + 任何運算子**: 自動完成輸入框
- **alert_name + 任何運算子**: 自由輸入框

**UX 改善建議**：
1. **策略精靈**：提供分步式的策略建立精靈，降低配置複雜度
2. **條件測試**：內建測試功能，模擬觸發條件和通知效果
3. **範本管理**：提供通知範本的視覺化編輯和預覽
4. **影響分析**：顯示策略將影響的用戶和通知量預估
5. **批量管理**：支援多個策略的批量開啟/關閉和修改
6. **智慧輸入優化**：持續優化智慧輸入的準確性和用戶體驗

#### 編輯通知策略2 [編輯通知策略2](images/74-彈窗-通知策略-編輯通知策略2.png)

**功能描述**：
- 通知策略編輯精靈的第二步：「設定通知管道」。
- 核心目標是為此策略指定接收通知的管道（即 Grafana 的 Contact Points）。
- 介面中包含一個「系統建議」區塊，並列出可供選擇的通知管道。

**相關 API 端點**：
- `GET /api/v1/notification-channels` - 獲取所有可用的通知管道列表。
- `GET /api/v1/teams/{id}/suggested-channels` - 獲取與資源群組關聯的團隊所推薦的通知管道。

**UX 改善建議**：
1. **清晰標示管道類型**：在每個管道名稱旁，應有明確的圖示（如 Slack, PagerDuty, Email）來標示其類型。
2. **預設選中**：「系統建議」的管道應預設為選中狀態，簡化操作。
3. **測試連結**：在每個管道旁提供一個「測試」按鈕，點擊後可以立即發送一條測試通知到該管道，以驗證其可用性。

**Jules 的分析與建議**：

此步驟將抽象的「團隊」與具體的「通知管道」連結起來，是確保告警能準確送達責任人的關鍵環節。

**後端架構與 API 設計**：
1.  **與 Grafana Contact Point 的映射**：此處選擇的每一個「通知管道」，在後端都對應一個 Grafana「接觸點 (Contact Point)」的 UUID。當使用者完成精靈時，這些 UUIDs 將被用來填充 Grafana Policy JSON 中的 `contact_point` 欄位。
2.  **「系統建議」的實現**：這個功能需要平台自身維護數據模型。
    *   `resource_groups` 表需要有一個 `responsible_team_id` 欄位。
    *   `teams` 表可以關聯到一組預設的 `notification_channel_ids`。
    *   當前端在步驟一選擇了某個資源群組後，它可以向後端請求建議的管道列表，後端根據上述關聯關係回傳推薦的管道。
3.  **API Payload 結構**：提交到 `POST /api/v1/notification-policies` 的 payload 中，此步驟的數據應為一組 ID：
    ```json
    {
      // ... data from step 1
      "contact_point_ids": ["uuid-of-pagerduty", "uuid-of-slack"],
      // ... data from step 3
    }
    ```

#### 編輯通知策略3 [編輯通知策略3](images/75-彈窗-通知策略-編輯通知策略3.png)

**功能描述**：
- 通知策略編輯精靈的第三步：「新增匹配條件」。
- 允許使用者在第一步選擇的「資源群組」基礎上，添加更精細的標籤匹配條件（Label Matchers），作為 AND 條件來進一步過濾告警。
- 介面包含一個條件建構器，以及一個「智慧輸入提示」區塊。

**相關 API 端點**：
- `GET /api/v1/tags` - 獲取所有可用的標籤鍵（Label keys）列表。
- `GET /api/v1/tags/{key}/values` - 根據標籤鍵獲取其可用的值列表（用於下拉選單和自動完成）。

**UX 改善建議**：
1. **邏輯關係清晰化**：明確標示所有條件之間是「AND」關係。如果未來要支援「OR」，需要提供更明確的 UI 進行分組。
2. **即時驗證**：對輸入的值進行即時驗證，例如，如果運算子是 `~` (regex match)，應驗證其是否為合法的正則表達式。
3. **刪除確認**：刪除條件時應有二次確認，防止誤操作。

**Jules 的分析與建議**：

此步驟是整個精靈的點睛之筆，它將 Grafana 強大但複雜的標籤匹配功能，透過「智慧輸入」這個 UX 設計，變得極為友好和高效。

**後端架構與 API 設計**：
1.  **Matcher 翻譯**：後端的核心任務是將前端傳來的一組條件陣列，準確地翻譯成 Grafana Policy JSON 中的 `matcher` 物件。例如，`[{key: "team", op: "=", val: "DevOps Team"}]` 會被翻譯成 `{"team": "DevOps Team"}`。
2.  **API Payload 結構**：在最終提交的 payload 中，此步驟的數據應為一個條件陣列：
    ```json
    {
      // ... data from step 1 & 2
      "additional_matchers": [
        { "key": "team", "operator": "=", "value": "DevOps Team" },
        { "key": "severity", "operator": "!=", "value": "info" }
      ]
    }
    ```
3.  **標籤值 API**：為了支援智慧輸入，後端必須提供高效的 API 來查詢標籤鍵和值。`GET /api/v1/tags/{key}/values` 的實作可能需要查詢 Prometheus/VictoriaMetrics 的元數據 API (`/api/v1/label/{label_name}/values`)，並對結果進行快取。

**「智慧輸入」功能深度分析**：
- **核心理念**：根據使用者選擇的**標籤鍵 (key)**，動態地切換最適合的**輸入元件**。
- **實現邏輯**：
    - **下拉選單 (Dropdown)**：適用於值是有限、固定的枚舉類型。例如 `severity` (`critical`, `warning`), `env` (`production`, `staging`)。這些固定的值應由平台管理員在「標籤管理」頁面中預先定義。
    - **自動完成 (Autocomplete)**：適用於值是動態的、數量龐大的標籤。例如 `instance`, `pod_name`。前端在使用者輸入時，呼叫後端 API 進行模糊查詢。
    - **自由輸入 (Free Text)**：適用於完全自定義的標籤，如 `alert_name` 或註解。
- **運算子與輸入框的聯動**：當使用者選擇 `in` 或 `not_in` 運算子時，輸入框應自動轉換為一個支援輸入多個值的「多選標籤輸入框 (Multi-select Tag Input)」。

#### 編輯通知管道 [編輯通知管道](images/76-彈窗-通知管道-編輯通知管道.png)

**功能描述**：
- 用於新增或編輯單一通知管道（Grafana Contact Point）的表單。
- 根據選擇的「管道類型」，動態顯示對應的設定欄位（如 Email 的收件人、Webhook 的 URL）。
- 提供「發送測試」和「儲存」操作。

**相關 API 端點**：
- `PUT /api/v1/notification-channels/{id}` - 更新通知管道，後端代理至 Grafana API。
- `POST /api/v1/notification-channels/{id}/test` - 發送測試通知，後端代理至 Grafana API。

**UX 改善建議**：
1. **動態表單**：表單欄位應根據「管道類型」的選擇而動態變化，並提供清晰的欄位說明和範例。
2. **即時回饋**：「發送測試」操作後，應在介面上顯示一個明確的成功或失敗提示。如果失敗，應顯示從後端收到的具體錯誤訊息，幫助使用者即時修正設定。
3. **安全提示**：對於需要輸入 Token 或 Webhook URL 的欄位，應有安全提示，告知使用者這些資訊將被安全儲存。

**Jules 的分析與建議**：

此表單是平台與 Grafana 接觸點配置互動的核心介面。其設計應聚焦於**易用性**和**即時驗證**。

**後端架構與 API 設計**：
1.  **API 代理**：`PUT` 和 `POST` 端點的核心職責是將前端傳來的簡化資料模型，準確地翻譯成 Grafana API 所需的 JSON 結構。例如，一個 Email 類型的管道，後端需要建構如下的 payload 去呼叫 Grafana：
    ```json
    {
      "name": "Default Email",
      "type": "email",
      "settings": {
        "addresses": "user1@example.com;user2@example.com"
      }
    }
    ```
2.  **同步的測試請求**：前端發起的「發送測試」請求應是一個**同步**操作。API `POST /api/v1/notification-channels/{id}/test` 應等待 Grafana 的測試請求完成，並將其成功或失敗的結果立即回傳給前端，以便 UI 能提供即時回饋。

#### 通知詳情 [通知詳情](images/77-抽屜-通知歷史-通知詳情.png)

**功能描述**：
- 從「通知歷史」列表點擊後，以抽屜 (Drawer) 形式展示的單條通知發送詳情。
- 清晰地展示了通知的發送時間、狀態、接收管道、關聯告警等元數據。
- 提供了通知內容的預覽、結構化的錯誤訊息（如果失敗）以及原始的 JSON Payload。

**相關 API 端點**：
- `GET /api/v1/notification-history/{id}` - 從平台自身的歷史記錄資料庫中獲取指定通知的完整詳情。

**UX 改善建議**：
1. **關聯導航**：「關聯告警」的內容應是一個超連結，點擊後可以直接打開該告警的「事件詳情」彈窗，方便使用者追溯問題的完整上下文。
2. **Payload 格式化**：「原始 Payload」區塊的 JSON 應被格式化、可摺疊、可複製，以提升可讀性和實用性。
3. **重試按鈕**：如果通知狀態是「FAILED」，應在此抽屜的底部或頂部提供一個「重新發送」按鈕，方便使用者進行手動重試。

**Jules 的分析與建議**：

此詳情視圖的設計非常出色，特別是**同時提供了簡潔的錯誤摘要和完整的原始 Payload**，這對於 SRE 進行故障排除至關重要。

**後端架構與 API 設計**：
1.  **數據來源**：如前述，此處所有數據均來自平台自身的 `notification_history` 資料庫表，而非直接來自 Grafana。
2.  **豐富的 Payload**：`GET /api/v1/notification-history/{id}` 回應的 JSON payload 應包含所有必要資訊，包括：
    *   `metadata`: 包含時間、狀態、操作者等。
    *   `channel_info`: 接收管道的詳細資訊。
    *   `alert_context`: 關聯告警的摘要和 ID。
    *   `content`: 格式化後的通知內容。
    *   `result`: 包含 `status` (`SUCCESS`/`FAILED`) 和 `error_message` (如果失敗)。
    *   `raw_payload`: 從 Grafana Webhook 接收到的原始 JSON 字串。
3.  **關聯事件 ID**：為了實現 UX 建議中的「關聯導航」，後端在記錄通知歷史時，必須從 Grafana 的 Webhook payload 中解析出告警的唯一標識，並將其與歷史記錄關聯起來。

#### 通知管道 [通知管道](images/71-頁面-通知管道.png)

**功能描述**：
- 通知發送管道管理
- 管道狀態和使用統計
- 通知管道表格：管道類型、名稱、配置狀態、使用統計、測試功能
- 管道配置和測試工具

**相關 API 端點**：
- `GET /api/v1/notification-channels` - 獲取通知管道列表
- `POST /api/v1/notification-channels` - 創建通知管道
- `PUT /api/v1/notification-channels/{id}` - 更新通知管道
- `DELETE /api/v1/notification-channels/{id}` - 刪除通知管道
- `POST /api/v1/notification-channels/{id}/test` - 測試通知管道

**UX 改善建議**：
1. **管道健康檢查**：即時顯示管道連接狀態
2. **使用量統計**：顯示各管道的使用情況和成本
3. **容錯配置**：設定管道故障時的備用方案
4. **模板管理**：支援通知模板的統一管理
5. **多租戶支援**：支援不同租戶的管道隔離

**Jules 的分析與建議**：

我已審閱此頁面設計。此頁面是平台管理 Grafana「接觸點 (Contact Points)」的統一介面。與「通知策略」頁面類似，它的核心價值在於提供一個比原生 Grafana 更好用、資訊更豐富的管理體驗。

**後端架構與 API 設計 (Grafana 代理模式)**：
1.  **核心職責 - Grafana 代理**：後端服務的核心職責是作為 Grafana ` /api/v1/provisioning/contact-points` API 端點的代理。
    *   `GET /api/v1/notification-channels`：呼叫 Grafana 的對應端點，獲取接觸點列表。
    *   `POST`, `PUT`, `DELETE`：將前端傳來的簡化模型，翻譯成 Grafana API 所需的完整 JSON 結構後，再發送請求。
2.  **API 設計 - 增值服務**：
    *   `GET /api/v1/notification-channels/statistics`：頂部的 KPI 指標（如「今日通知量」）應從 Redis 快取中讀取，該快取由分析 `notification_history` 表的背景作業維護。
    *   `POST /api/v1/notification-channels/{id}/test`：此 API 直接代理 Grafana 的測試端點。重要的是，後端應**同步等待** Grafana 的測試結果，並將其立即回傳給前端，以便 UI 能夠即時顯示測試是成功還是失敗，以及失敗的原因。
3.  **健康檢查與狀態儲存**：
    *   列表中的「最近測試結果」和「最近測試時間」欄位，其資料來源**不是** Grafana。
    *   平台需要一個背景排程作業，定期（例如每 15 分鐘）遍歷所有已設定的通知管道，並呼叫它們各自的「測試」API。
    *   該作業會將每一次的測試結果（成功/失敗、時間戳、錯誤訊息）儲存在平台自身的資料庫中（例如一張 `channel_health_checks` 表）。`GET /api/v1/notification-channels` API 在回傳列表時，會附加上這些最近的健康檢查狀態。

**UX/UI 強化建議**：
1.  **即時、可操作的測試**：
    *   在每一行的「操作」欄中，「測試」按鈕是關鍵。點擊後，UI 應顯示一個等待狀態（如旋轉圖示），並在收到後端 API 的同步回傳後，立即將該行的「最近測試結果」更新為 `SUCCESS` 或 `FAILED`，並短暫高亮該儲存格。這種即時反饋對於使用者配置和除錯至關重要。
2.  **使用量洞察**：
    *   在表格中增加一欄「**關聯策略數**」。此數據顯示有多少條「通知策略」正在使用這個管道。
    *   此數字應可點擊。點擊後，會彈出一個對話框，列出所有關聯的策略名稱。
    *   這個功能有助於管理員在修改或刪除一個管道前，評估其影響範圍。
3.  **管道類型視覺化**：
    *   在「類型」欄位，除了文字（如 `Slack`, `Email`），還應顯示對應服務的官方圖示。這能讓使用者更快地掃描和識別管道類型。
4.  **範本化與標準化**：
    *   提供「從範本建立」的功能。管理員可以預先設定好適用於整個組織的標準管道（例如，一個指向公司標準 PagerDuty 服務的管道），普通使用者可以直接選用，無需關心其具體設定細節。

#### 通知歷史 [通知歷史](images/72-頁面-通知歷史.png)

**功能描述**：
- 通知發送歷史記錄
- 通知統計和投遞狀態
- 通知歷史表格：發送時間、接收者、管道、狀態、主題、內容摘要
- 歷史記錄查詢和過濾

**相關 API 端點**：
- `GET /api/v1/notification-history` - 獲取通知歷史
- `GET /api/v1/notification-history/{id}` - 獲取通知詳情
- `POST /api/v1/notification-history/resend` - 重新發送通知

**UX 改善建議**：
1. **投遞追蹤**：顯示通知的完整投遞路徑
2. **失敗分析**：分析通知失敗的原因和解決方案
3. **批量重發**：支援批量重新發送失敗的通知
4. **統計報表**：生成通知效果統計報表
5. **即時更新**：支援實時通知狀態更新

**Jules 的分析與建議**：

我已審閱此頁面設計。通知歷史是平台**超越 Grafana 原生功能的核心價值之一**。它將無狀態的通知發送，轉化為一個**可追蹤、可審計、可除錯**的歷史記錄。此功能的實現，是平台作為「統一管理平面」的關鍵證明。

**後端架構與資料流程**：
1.  **核心引擎 - Webhook 攔截器**：
    *   為了建立這份歷史記錄，平台**必須**設定一個統一的 Webhook 端點 (e.g., `/api/v1/webhooks/receiver`)。
    *   在 Grafana 中，**所有**的通知管道 (Contact Points) 都**不應**直接指向 Slack、PagerDuty 等終端，而是**全部指向這個平台統一的 Webhook 端點**。
    *   當告警觸發時，Grafana 會將一個包含所有告警資訊的 Payload 發送到這個 Webhook。
2.  **非同步處理與儲存**：
    *   Webhook 端點在接收到請求後，應只做最少的驗證，然後立即將完整的 Payload 推送到一個**訊息佇列 (Message Queue)** 中（如 Redis Streams 或 Kafka），並回傳 `200 OK` 給 Grafana。
    *   一個獨立的**通知處理服務 (Notification Processor)** 會消費佇列中的訊息。它負責：
        a.  解析 Payload，提取關鍵資訊（告警名稱、標籤、目標管道等）。
        b.  將一筆包含 `raw_payload` 的記錄寫入**平台自身的歷史資料庫** (`notification_history` 表)，初始狀態為 `PENDING`。
        c.  根據通知策略，將通知轉發到真正的目標管道（如 Slack API）。
        d.  等待第三方管道的回應後，更新歷史記錄的狀態為 `SUCCESS` 或 `FAILED`，並記錄錯誤訊息。
3.  **API 設計**：
    *   `GET /api/v1/notification-history`：此 API 應查詢平台自身的 `notification_history` 資料庫，並支援基於狀態、管道、時間範圍和關鍵字的後端篩選。
    *   `POST /api/v1/notification-history/{id}/resend`：此 API 應讀取指定歷史記錄的 `raw_payload`，並重新將其推送到訊息佇列中進行處理，從而實現「重新發送」功能。

**UX/UI 強化建議**：
1.  **無縫的上下文鑽取 (Contextual Drill-Down)**：
    *   表格中的「關聯告警」欄位**必須**是一個超連結。點擊後，應在一個抽屜或彈窗中，打開觸發此通知的**原始事件的詳情**。這為使用者提供了從「通知結果」回溯到「問題根源」的關鍵路徑。
2.  **強化的日誌詳情**：
    *   點擊任一歷史記錄，應打開一個詳情抽屜 (如 `images/77...` 所示)。
    *   此抽屜中，如果狀態為 `FAILED`，**必須**清晰地展示從第三方管道（如 Slack API）返回的**完整錯誤訊息**，而不只是一個通用的「失敗」狀態。
    *   詳情中應包含一個經過格式化、可摺疊、可複製的**原始 Webhook Payload** 區塊，這對於進階除錯至關重要。
3.  **智慧化篩選**：
    *   除了現有的篩選器，應增加一個基於「**告警規則名稱**」的篩選器，讓使用者可以快速查看由某一個特定規則觸發的所有通知歷史。

---

## 8.設定-平台管理

#### 標籤管理 [標籤管理](images/80-頁面-標籤管理.png)

*關聯圖片: [新增標籤](images/83-彈窗-標籤管理-新增標籤.png), [管理標籤值](images/84-彈窗-標籤管理-管理標籤值.png), [編輯標籤](images/85-彈窗-標籤管理-編輯標籤.png)*

**功能描述**：
- 一個集中的**標籤治理 (Tag Governance)** 模組，用於定義和管理整個平台的元數據標準。
- 主頁面 (80) 提供已定義標籤的列表，包含其分類、允許的值、是否必填以及在系統中的使用次數。
- 彈出視窗支援標籤的完整生命週期管理：
    - (83) 新增標籤：定義一個新的標籤鍵 (key) 的綱要 (schema)。
    - (85) 編輯標籤：修改標籤鍵的綱要。
    - (84) 管理標籤值：為一個標籤鍵定義一組預設的、允許的值 (values)，並可為每個值指定顏色。

**相關 API 端點**：
- `GET /api/v1/tags`: 獲取所有已定義的標籤綱要列表。
- `POST /api/v1/tags`: 建立一個新的標籤綱要。
- `PUT /api/v1/tags/{id}`: 更新一個標籤綱要。
- `GET /api/v1/tags/{id}/values`: 獲取指定標籤的所有允許值。
- `POST /api/v1/tags/{id}/values`: 為指定標籤新增一個允許值。

**UX 改善建議**：
1. **標籤合規性報告**：增加一個「合規報告」分頁，顯示所有違反標籤規則（如缺少必填標籤、使用了未定義的值）的資源列表。
2. **視覺化使用分佈**：「使用次數」應可點擊，點擊後顯示該標籤及其值的詳細分佈圖表和使用該標籤的資源列表。
3. **自動化標籤建議**：整合 AI 功能，掃描資源屬性並自動建議應用的標準化標籤，加速標籤的落地和標準化過程。

**Jules 的分析與建議**：

此功能是平台從一個單純的「監控工具」提升為一個「營運治理平台」的核心。一個混亂的標籤系統會讓告警路由、成本分攤、權限管理等所有上層建築都無法有效建立。因此，這個模組的定位是**平台元數據的單一事實來源 (SSOT)**。

**後端架構與 API 設計**：
1.  **獨立的數據模型**：後端必須有獨立的資料庫表（如 `tags`, `tag_values`）來儲存這些治理規則。這與監控系統中實際存在的標籤是分離的，前者是「規範」，後者是「現實」。
2.  **數據驅動的智慧輸入**：此模組是「編輯通知策略」中「智慧輸入」功能的**數據來源**。當使用者在其他地方需要輸入標籤時，前端應呼叫此處的 API (`GET /api/v1/tags/{key}/values`) 來獲取下拉選單或自動完成的選項。
3.  **非同步的分析任務**：
    *   **使用次數計算**：`usage_count` 欄位需要一個**背景排程作業**，定期去查詢監控系統（如 Prometheus/VictoriaMetrics 的元數據 API）或日誌系統，統計各個標籤的使用情況，並將結果寫回 `tags` 表。這絕不能在 `GET /api/v1/tags` 的請求中即時計算。
    *   **合規性檢查**：同樣，一個背景作業需要定期從 CMDB 或雲端 API 獲取資源列表及其標籤，與本模組定義的規則進行比對，並將不合規的結果儲存到一張 `tag_compliance_violations` 表中，供「合規報告」頁面查詢。

**與其他系統的整合**：
- **CMDB 同步**：此模組應能與企業的 CMDB 進行雙向同步，確保標籤定義的一致性。
- **IaC 工具整合**：提供 API 或匯出功能，讓 Terraform/Ansible 等 IaC (Infrastructure as Code) 工具可以直接消費這裡定義的標籤規範，從源頭保證新建資源的標籤合規性。

#### 郵件設定 [郵件設定](images/81-頁面-郵件設定.png)

**功能描述**：
- 郵件伺服器配置管理
- 郵件發送統計和狀態監控
- SMTP 配置表單：伺服器地址、埠號、認證信息、加密設定
- 郵件測試和配置驗證

**相關 API 端點**：
- `GET /api/v1/settings/email` - 獲取郵件設定
- `PUT /api/v1/settings/email` - 更新郵件設定
- `POST /api/v1/settings/email/test` - 測試郵件配置

**UX 改善建議**：
1. **配置向導**：提供 SMTP 配置的逐步指導
2. **安全檢查**：驗證 SMTP 連接的安全性
3. **發送限制**：顯示郵件發送限制和配額
4. **模板預覽**：預覽郵件模板的效果
5. **故障排除**：提供常見配置問題的解決方案

#### 身份驗證 [身份驗證](images/82-頁面-身份驗證.png)

**功能描述**：
- 用戶認證和權限管理設定
- 認證統計和安全性指標
- 認證配置：密碼策略、多因素認證、會話管理
- 安全性設定和合規檢查

**相關 API 端點**：
- `GET /api/v1/settings/auth` - 獲取認證設定
- `PUT /api/v1/settings/auth` - 更新認證設定
- `GET /api/v1/auth/statistics` - 獲取認證統計

**UX 改善建議**：
1. **安全性評估**：顯示當前安全配置的安全等級
2. **合規檢查**：檢查是否符合安全標準要求
3. **風險評估**：分析潛在的安全風險
4. **配置建議**：提供安全性最佳實踐建議
5. **監控儀表板**：顯示認證相關的安全指標

---

## 9.個人資料

### 個人資料

*關聯圖片: [個人資訊](images/90-頁面-個人資料-個人資訊.png), [偏好設定](images/91-頁面-個人資料-偏好設定.png), [密碼安全](images/92-頁面-個人資料-密碼安全.png)*

**Jules 的分析與建議**：

我已審閱此區塊的所有頁面。根據 `docs/architecture.md` 中「身份認證委託給 Keycloak」的核心原則，此區塊的設計必須進行重大調整，以確保職責分離，將身份管理完全交由 Keycloak 處理。目前的 UI 設計 (圖片 90 和 92) 與此架構存在直接衝突。

---

#### 個人資訊

**功能描述 (重構後)**：
- **唯讀地**展示當前登入使用者的核心身份資訊（姓名、電子郵件）。
- 提供一個明確的連結，引導使用者到 Keycloak 的帳號管理中心去修改這些資訊。

**API 設計 (重構後)**：
- `GET /api/v1/users/me`: 此 API 應從使用者請求中的 JWT (JSON Web Token) 的宣告 (claims) 中解析出 `name` 和 `email`。後端**不應**從本地資料庫讀取這些資訊。
- **移除** `PUT /api/v1/users/profile` 端點，因為平台不負責更新使用者個人資料。

**UX/UI 重新設計**：
1.  **欄位變更為唯讀**：「姓名」和「電子郵件」的輸入框必須改為**純文字顯示**，不可編輯。
2.  **操作按鈕變更為連結**：移除「更新個人資訊」按鈕，替換為一個超連結，文字為「**前往 Keycloak 管理個人資料**」。此連結應指向 Keycloak Account Console 的 URL。

---

#### 偏好設定

**功能描述 (符合架構)**：
- 管理使用者在**本平台內**的個人化設定，這些設定與其核心身份無關。
- 例如：介面主題、預設登入頁面、時區偏好等。

**API 設計 (符合架構)**：
- `GET /api/v1/users/preferences`
- `PUT /api/v1/users/preferences`
- 這兩個 API 應在平台自身的資料庫中讀寫一張 `user_preferences` 表，並透過從 JWT 中獲取的使用者 UUID 進行關聯。此部分的設計是正確的。

---

#### 密碼安全

**功能描述 (重構後)**：
- 不提供任何修改密碼的表單。
- 提供一個明確的連結，引導使用者到 Keycloak 去執行所有與密碼相關的安全操作。

**API 設計 (重構後)**：
- **移除** `POST /api/v1/users/change-password` 端點。平台後端絕不能處理任何與密碼相關的邏輯。

**UX/UI 重新設計**：
1.  **移除整個表單**：必須**完全移除**「目前密碼」、「新密碼」、「確認新密碼」三個輸入框以及「更新密碼」按鈕。
2.  **替換為引導連結**：在頁面上放置一個醒目的按鈕或連結，文字為「**前往 Keycloak 修改密碼或設定 2FA**」。此連結應將使用者重定向到 Keycloak Account Console 的「Security」分頁。

---

## 🔗 導航結構

```
SRE 平台
├── 📋 事件 (Incidents) - Tab 管理 (事件列表 | 告警規則 | 靜音規則)
├── 💽 資源 (Resources) - Tab 管理 (資源列表 | 資源群組)
├── 📊 儀表板 (Dashboards) - Tab 管理 (資源總覽)
├── 📈 分析 (Analysis) - Tab 管理 (容量規劃)
├── 🤖 自動化 (Automation) - Tab 管理 (腳本庫 | 排程管理 | 執行日誌)
└── ⚙️ 設定 (Settings) [父選單 - 預設展開]
    ├── 👥 身份與存取管理 - Tab 管理 (人員管理 | 團隊管理 | 角色管理)
    ├── 📢 通知管理 - Tab 管理 (通知管道 | 通知策略)
    ├── ⚙️ 平台設定 - Tab 管理 (標籤管理 | 郵件設定 | 身份驗證)
    └── 🖥️ 平台維運 - Tab 管理 (平台診斷 | 審計日誌)

```

---

## 🎯 架構特點

### **設計哲學 - 「分層聚焦、聚合體驗」**:
- **分層聚焦**: 左側主導航的每個入口都對應單一SRE工作領域
- **聚合體驗**: 策略性使用Tab頁籤，將相關操作聚合在單一工作區

### **分層架構**:
- **業務層**: 事件、資源、分析、自動化 - 核心運營功能
- **管理層**: 人員權限、通知管理、平台設定 - 系統治理
- **運營層**: 平台維運 - 平台運維
- **個人層**: 個人設定、偏好配置 - 人員體驗

### **Tab 頁籤架構**:
- **事件中心**: 告警列表 | 告警規則 | 靜音規則
- **自動化中心**: 腳本庫 | 排程管理 | 執行日誌
- **權限中心**: 人員管理 | 團隊管理 | 角色管理
- **平台設定**: 標籤管理 | 郵件設定 | 身份驗證
- **通知中心**: 通知管道 | 通知策略
- **平台運營中心**: 平台診斷 | 審計日誌
- **個人資料與偏好設定**: 個人資訊 | 密碼安全 | 偏好設定

### **功能完整性**:
- **核心功能**: 100% 實現 (事件、資源、自動化)
- **分析功能**: 89% 實現 (8/9個頁面)
- **管理功能**: 100% 實現 (人員、通知、平台設定)
- **個人功能**: 100% 實現 (個人化設定)

---

## 🎨 UI/UX 設計原則與規範

### 核心設計原則

1. **一致性**: 所有組件遵循統一的視覺語言和交互模式
2. **可訪問性**: 支援鍵盤導航和屏幕閱讀器
3. **響應式**: 適應不同螢幕尺寸
4. **效能優化**: 使用 React.memo 優化渲染性能

### 分層架構設計

- **業務層**: 事件、資源、分析、自動化 - 核心運營功能
- **管理層**: 人員權限、通知管理、平台設定 - 系統治理
- **運營層**: 平台維運 - 平台運維
- **個人層**: 個人設定、偏好配置 - 人員體驗

### 設計系統元件

#### 按鈕設計規範
```jsx
// 主要操作 (新增、保存等)
<Button type="primary">主要操作</Button>

// 表格行內操作
<Button type="text" icon={<Icon />} />

// 危險操作 (刪除等)
<Button type="text" danger icon={<DeleteOutlined />} />
```

#### Tab 頁籤規範
```jsx
// 標題格式: "中心名稱"
<Tabs defaultActiveKey="tab1">
  <TabPane tab="功能一" key="tab1">內容1</TabPane>
  <TabPane tab="功能二" key="tab2">內容2</TabPane>
</Tabs>
```

#### 表格設計規範
```jsx
<Table
  size="small"
  rowSelection={rowSelection}
  columns={optimizedColumns}
  scroll={{ y: 'calc(100vh - 300px)' }}
/>
```

### 📊 平台功能統計

#### **路由頁面總數**: 7 個
- ✅ **已實現**: 7 個 (100%)
- 🔄 **功能完善中**: 部分頁面的子功能

#### **主要功能區塊** (Tab 整合架構):
1. **儀表板**: 1 個路由頁面 (多個儀表板視圖)
2. **事件管理**: 1 個路由頁面 (3 個 Tab: 事件列表、規則管理、靜音規則)
3. **資源管理**: 1 個路由頁面 (2 個 Tab: 資源列表、資源群組)
4. **分析**: 1 個路由頁面 (容量規劃等分析功能)
5. **自動化**: 1 個路由頁面 (3 個 Tab: 腳本庫、排程管理、執行日誌)
6. **系統管理**: 1 個路由頁面 (多個管理 Tab)
7. **個人中心**: 1 個路由頁面 (個人設定相關)

#### **Tab 頁籤統計**:
- **事件中心**: 2 個 Tab (去除告警列表)
- **自動化中心**: 3 個 Tab
- **權限中心**: 3 個 Tab
- **通知中心**: 2 個 Tab
- **平台運營中心**: 2 個 Tab
- **個人資料**: 3 個 Tab

#### **人員角色權限**:
- **超級管理員**: 全部功能訪問
- **團隊管理員**: 大部分功能 (除人員管理)
- **團隊成員**: 基本功能 (資源、事件、自動化)

#### **最新更新** 📅:
- **時間範圍篩選功能**: 通知歷史頁面和執行日誌頁面添加時間範圍篩選功能
- **側邊選單優化**: 設定父選單預設展開，提升人員體驗
- **UI 功能增強**: 多個頁面工具欄功能完善，包含時間範圍選擇器
- **儀表板模組新增**: 新增儀表板主頁面，資源總覽作為子頁面
- **資訊架構重構**: 儀表板提升為頂級模組，提供全局運營視野
- **資源管理優化**: 移除資源管理頁籤中的資源總覽，實現功能分離
- **事件管理優化**: 移除告警列表頁籤，簡化事件管理流程
- **Tab 頁籤架構**: 全面採用聚合體驗設計
- **實現率提升**: 從77%提升到77%，頁面結構更加精簡

### 待優化建議清單

#### 高優先級改進（立即實施）

##### 1. 設計系統完善
- **色彩系統優化**: 強化語意色彩和狀態色彩細分
- **動效系統建立**: 統一動效時長和緩動函數
- **圖示系統統一**: 建立統一的圖示使用規範

##### 2. 互動體驗優化
- **鍵盤快捷鍵系統**: 實現全域和頁面級快捷鍵
- **深色/淺色主題切換**: 完善主題切換功能
- **載入狀態優化**: 統一Skeleton和Spin的使用規範

##### 3. 功能增強
- **元件庫文檔**: 建立完整的使用指南和範例
- **空狀態設計統一**: 設計統一的空狀態介面
- **錯誤處理優化**: 統一錯誤提示和恢復機制

#### 中優先級改進（2週內）

##### 1. 表單體驗優化
- **表單自動儲存草稿**: 實現表單草稿自動儲存
- **多步驟表單體驗**: 優化精靈式表單的導航和驗證
- **表單驗證視覺反饋**: 增強表單驗證的視覺提示

##### 2. 圖表互動優化
- **圖表配色方案統一**: 建立統一的圖表色彩系統
- **圖表載入動畫**: 優化圖表載入體驗
- **圖表匯出功能**: 支援圖表資料匯出

##### 3. 效能優化
- **虛擬滾動實現**: 針對大資料量表格實現虛擬滾動
- **元件渲染優化**: 使用React.memo和useMemo優化性能
- **圖片懶載入**: 實現圖片和重資源的懶載入

#### 低優先級改進（1月內）

##### 1. 進階功能
- **個人化設定儲存**: 用戶偏好設定持久化
- **國際化準備**: 建立多語言支援架構
- **可及性提升**: 增強螢幕閱讀器支援

##### 2. 開發體驗
- **設計系統網站**: 建立線上元件展示和文檔
- **自動化UI測試**: 實現UI元件自動化測試
- **效能監控**: 建立UI效能監控機制

### 實施進度追蹤

#### 已完成 ✅
- PlatformButton 和 PlatformModal 元件建立
- 智能輸入功能實現
- 表格密度系統實現
- Modal 標準化配置
- 響應式設計實現
- 模擬資料真實性提升

#### 進行中 🔄
- 設計系統色彩優化
- 動效系統建立
- 鍵盤快捷鍵實現

#### 待實施 📋
- 表單自動儲存草稿
- 虛擬滾動優化
- 個人化設定儲存
- 國際化基礎設施

---

## 🚀 發展建議

### **優先實現 (Phase 1)**:
1. **Tab 頁籤實現**: 將現有頁面重構成Tab架構
2. **批次操作功能**: 實現告警和資源列表的批次處理
3. **導出功能**: 添加數據導出能力
4. **按鈕規範化**: 統一所有操作按鈕的樣式和圖示

### **功能增強 (Phase 2)**:
1. **移動端優化**: 響應式設計和觸摸友好界面
2. **性能優化**: 圖表渲染優化和數據加載優化
3. **人員體驗**: 加載狀態、進度指示器、空狀態處理

### **架構擴展 (Phase 3)**:
1. **API 管理**: RESTful API 文檔和測試工具整合
2. **日誌管理**: 集中式日誌收集和分析系統
3. **災難恢復**: 高可用性和數據備份策略

### **技術優化**:
1. **元件抽象**: 建立通用元件庫 (ActionButton, BatchActionBar等)
2. **設計系統**: 統一的顏色、間距、字體規範
3. **代碼重構**: 清理重複代碼，提升維護性

---

## 📈 實施進度追蹤

### **已完成 ✅**:
- **資訊架構設計**: 分層聚焦、聚合體驗的設計哲學
- **網站地圖重構**: 完整的Tab頁籤架構和導航結構
- **功能統計更新**: 採用 Tab 整合架構，7 個路由頁面全部實現，實現率 100%

### **進行中 🔄**:
- **代碼重構任務**: 7個核心優化任務的規劃和準備
- **設計規範建立**: 操作按鈕和圖示的統一標準

### **待實施 📋**:
- **具體功能實現**: Tab頁籤、批次操作、導出功能等
- **人員體驗優化**: 載入狀態、錯誤處理、空狀態等
- **性能和可維護性**: 代碼重構、元件抽象等

---

## 🎨 設計規範總結

### **按鈕設計規範**:
```jsx
// 主要操作 (新增、保存等)
<Button type="primary">主要操作</Button>

// 表格行內操作
<Button type="text" icon={<Icon />} />

// 危險操作 (刪除等)
<Button type="text" danger icon={<DeleteOutlined />} />
```

### **Tab 頁籤規範**:
```jsx
// 標題格式: "中心名稱"
<Tabs defaultActiveKey="tab1">
  <TabPane tab="功能一" key="tab1">內容1</TabPane>
  <TabPane tab="功能二" key="tab2">內容2</TabPane>
</Tabs>
```

### **表格設計規範**:
```jsx
<Table
  size="small"
  rowSelection={rowSelection}
  columns={optimizedColumns}
  scroll={{ y: 'calc(100vh - 300px)' }}
/>
```

---

*更新時間: 2025年時間範圍篩選與選單優化 | 實現率: 78% | 設計哲學: 分層聚焦、聚合體驗* 🌟